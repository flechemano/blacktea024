{"version":3,"file":"fetch.js","sourceRoot":"","sources":["../src/fetch.ts"],"names":[],"mappings":"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","sourcesContent":["import type { JsonRpcMiddleware } from '@metamask/json-rpc-engine';\nimport { createAsyncMiddleware } from '@metamask/json-rpc-engine';\nimport type { JsonRpcError, DataWithOptionalCause } from '@metamask/rpc-errors';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Json, JsonRpcParams, JsonRpcRequest } from '@metamask/utils';\n\nimport type { Block } from './types';\nimport { timeout } from './utils/timeout';\n\nconst RETRIABLE_ERRORS: string[] = [\n  // ignore server overload errors\n  'Gateway timeout',\n  'ETIMEDOUT',\n  // ignore server sent html error pages\n  // or truncated json responses\n  'failed to parse response body',\n  // ignore errors where http req failed to establish\n  'Failed to fetch',\n];\n\nexport interface PayloadWithOrigin extends JsonRpcRequest {\n  origin?: string;\n}\ninterface Request {\n  method: string;\n  headers: Record<string, string>;\n  body: string;\n}\ninterface FetchConfig {\n  fetchUrl: string;\n  fetchParams: Request;\n}\n\n/**\n * Create middleware for sending a JSON-RPC request to the given RPC URL.\n *\n * @param options - Options\n * @param options.btoa - Generates a base64-encoded string from a binary string.\n * @param options.fetch - The `fetch` function; expected to be equivalent to `window.fetch`.\n * @param options.rpcUrl - The URL to send the request to.\n * @param options.originHttpHeaderKey - If provider, the origin field for each JSON-RPC request\n * will be attached to each outgoing fetch request under this header.\n * @returns The fetch middleware.\n */\nexport function createFetchMiddleware({\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  btoa,\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  fetch,\n  rpcUrl,\n  originHttpHeaderKey,\n}: {\n  btoa: (stringToEncode: string) => string;\n  fetch: typeof global.fetch;\n  rpcUrl: string;\n  originHttpHeaderKey?: string;\n}): JsonRpcMiddleware<JsonRpcParams, Json> {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const { fetchUrl, fetchParams } = createFetchConfigFromReq({\n      btoa,\n      req,\n      rpcUrl,\n      originHttpHeaderKey,\n    });\n\n    // attempt request multiple times\n    const maxAttempts = 5;\n    const retryInterval = 1000;\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const fetchRes = await fetch(fetchUrl, fetchParams);\n        // check for http errrors\n        checkForHttpErrors(fetchRes);\n        // parse response body\n        const rawBody: string = await fetchRes.text();\n        let fetchBody: Record<string, Block>;\n        try {\n          fetchBody = JSON.parse(rawBody);\n        } catch (_) {\n          throw new Error(\n            `FetchMiddleware - failed to parse response body: \"${rawBody}\"`,\n          );\n        }\n        const result: Block = parseResponse(fetchRes, fetchBody);\n        // set result and exit retry loop\n        res.result = result;\n        return;\n      } catch (err: any) {\n        const errMsg: string = err.toString();\n        const isRetriable: boolean = RETRIABLE_ERRORS.some((phrase) =>\n          errMsg.includes(phrase),\n        );\n        // re-throw error if not retriable\n        if (!isRetriable) {\n          throw err;\n        }\n      }\n      // delay before retrying\n      await timeout(retryInterval);\n    }\n  });\n}\n\nfunction checkForHttpErrors(fetchRes: Response): void {\n  // check for errors\n  switch (fetchRes.status) {\n    case 405:\n      throw rpcErrors.methodNotFound();\n\n    case 418:\n      throw createRatelimitError();\n\n    case 503:\n    case 504:\n      throw createTimeoutError();\n\n    default:\n      break;\n  }\n}\n\nfunction parseResponse(fetchRes: Response, body: Record<string, Block>): Block {\n  // check for error code\n  if (fetchRes.status !== 200) {\n    throw rpcErrors.internal({\n      message: `Non-200 status code: '${fetchRes.status}'`,\n      data: body,\n    });\n  }\n\n  // check for rpc error\n  if (body.error) {\n    throw rpcErrors.internal({\n      data: body.error,\n    });\n  }\n  // return successful result\n  return body.result;\n}\n\n/**\n * Generate `fetch` configuration for sending the given request to an RPC API.\n *\n * @param options - Options\n * @param options.btoa - Generates a base64-encoded string from a binary string.\n * @param options.rpcUrl - The URL to send the request to.\n * @param options.originHttpHeaderKey - If provider, the origin field for each JSON-RPC request\n * will be attached to each outgoing fetch request under this header.\n * @param options.req\n * @returns The fetch middleware.\n */\nexport function createFetchConfigFromReq({\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  btoa,\n  req,\n  rpcUrl,\n  originHttpHeaderKey,\n}: {\n  btoa: (stringToEncode: string) => string;\n  rpcUrl: string;\n  originHttpHeaderKey?: string;\n  req: PayloadWithOrigin;\n}): FetchConfig {\n  const parsedUrl: URL = new URL(rpcUrl);\n  const fetchUrl: string = normalizeUrlFromParsed(parsedUrl);\n\n  // prepare payload\n  // copy only canonical json rpc properties\n  const payload: JsonRpcRequest = {\n    id: req.id,\n    jsonrpc: req.jsonrpc,\n    method: req.method,\n    params: req.params,\n  };\n\n  // extract 'origin' parameter from request\n  const originDomain: string | undefined = req.origin;\n\n  // serialize request body\n  const serializedPayload: string = JSON.stringify(payload);\n\n  // configure fetch params\n  const fetchParams: Request = {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: serializedPayload,\n  };\n\n  // encoded auth details as header (not allowed in fetch url)\n  if (parsedUrl.username && parsedUrl.password) {\n    const authString = `${parsedUrl.username}:${parsedUrl.password}`;\n    const encodedAuth = btoa(authString);\n    fetchParams.headers.Authorization = `Basic ${encodedAuth}`;\n  }\n\n  // optional: add request origin as header\n  if (originHttpHeaderKey && originDomain) {\n    fetchParams.headers[originHttpHeaderKey] = originDomain;\n  }\n\n  return { fetchUrl, fetchParams };\n}\n\nfunction normalizeUrlFromParsed(parsedUrl: URL): string {\n  let result = '';\n  result += parsedUrl.protocol;\n  result += `//${parsedUrl.hostname}`;\n  if (parsedUrl.port) {\n    result += `:${parsedUrl.port}`;\n  }\n  result += `${parsedUrl.pathname}`;\n  result += `${parsedUrl.search}`;\n  return result;\n}\n\nfunction createRatelimitError(): JsonRpcError<DataWithOptionalCause> {\n  return rpcErrors.internal({ message: `Request is being rate limited.` });\n}\n\nfunction createTimeoutError(): JsonRpcError<DataWithOptionalCause> {\n  let msg = `Gateway timeout. The request took too long to process. `;\n  msg += `This can happen when querying logs over too wide a block range.`;\n  return rpcErrors.internal({ message: msg });\n}\n"]}