{"version":3,"file":"string.js","sourceRoot":"","sources":["../../src/parsers/string.ts"],"names":[],"mappings":";;;AAAA,2CAA+D;AAE/D,mCAAgC;AAGnB,QAAA,MAAM,GAAmB;IACpC,SAAS,EAAE,IAAI;IAEf;;;;;;OAMG;IACH,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,KAAK,QAAQ;IAEnC;;;;;;;;OAQG;IACH,aAAa;QACX,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;;;;;;;;OASG;IACH,MAAM,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE;QACrC,2EAA2E;QAC3E,uBAAuB;QACvB,OAAO,aAAK,CAAC,MAAM,CAAC;YAClB,IAAI,EAAE,OAAO;YACb,MAAM;YACN,KAAK,EAAE,IAAA,qBAAa,EAAC,KAAK,CAAC;YAC3B,MAAM;YACN,KAAK;SACN,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,IAAI;QACT,2EAA2E;QAC3E,2CAA2C;QAC3C,OAAO,IAAA,qBAAa,EAAC,aAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;IAC3C,CAAC;CACF,CAAC","sourcesContent":["import { bytesToString, stringToBytes } from '@metamask/utils';\n\nimport { bytes } from './bytes';\nimport { Parser } from './parser';\n\nexport const string: Parser<string> = {\n  isDynamic: true,\n\n  /**\n   * Check if a type is a string type. Since `string` is a simple type, this\n   * is just a check if the type is \"string\".\n   *\n   * @param type - The type to check.\n   * @returns Whether the type is a string type.\n   */\n  isType: (type) => type === 'string',\n\n  /**\n   * Get the byte length of an encoded string type. Since `string` is a simple\n   * type, this will always return 32.\n   *\n   * Note that actual strings are variable in length, but the encoded static\n   * value (pointer) is always 32 bytes long.\n   *\n   * @returns The byte length of an encoded string.\n   */\n  getByteLength(): number {\n    return 32;\n  },\n\n  /**\n   * Encode the given string value to a byte array.\n   *\n   * @param args - The encoding arguments.\n   * @param args.buffer - The byte array to add to.\n   * @param args.value - The string value to encode.\n   * @param args.packed - Whether to use packed encoding.\n   * @param args.tight - Whether to use non-standard tight encoding.\n   * @returns The bytes with the encoded string value added to it.\n   */\n  encode({ buffer, value, packed, tight }): Uint8Array {\n    // Strings are encoded as UTF-8 bytes, so we use the bytes parser to encode\n    // the string as bytes.\n    return bytes.encode({\n      type: 'bytes',\n      buffer,\n      value: stringToBytes(value),\n      packed,\n      tight,\n    });\n  },\n\n  /**\n   * Decode the given byte array to a string value.\n   *\n   * @param args - The decoding arguments.\n   * @returns The decoded string value.\n   */\n  decode(args): string {\n    // Strings are encoded as UTF-8 bytes, so we use the bytes parser to decode\n    // the bytes, and convert them to a string.\n    return bytesToString(bytes.decode(args));\n  },\n};\n"]}