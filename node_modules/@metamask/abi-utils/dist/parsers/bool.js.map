{"version":3,"file":"bool.js","sourceRoot":"","sources":["../../src/parsers/bool.ts"],"names":[],"mappings":";;;AAAA,2CAA6D;AAC7D,6CAAsE;AAEtE,sCAAwC;AACxC,qCAAkC;AAQlC,MAAM,cAAc,GAAG,IAAA,oBAAM,EAC3B,IAAA,qBAAO,GAAE,EACT,IAAA,mBAAK,EAAC,CAAC,IAAA,qBAAO,EAAC,MAAM,CAAC,EAAE,IAAA,qBAAO,EAAC,OAAO,CAAC,CAAC,CAAC,EAC1C,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,KAAK,MAAM,CAC5B,CAAC;AAEF;;;;;;;;;GASG;AACI,MAAM,eAAe,GAAG,CAAC,KAAkB,EAAU,EAAE;IAC5D,IAAI;QACF,MAAM,YAAY,GAAG,IAAA,oBAAM,EAAC,KAAK,EAAE,cAAc,CAAC,CAAC;QACnD,IAAI,YAAY,EAAE;YAChB,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;SAClB;QAED,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;KAClB;IAAC,MAAM;QACN,MAAM,IAAI,oBAAW,CACnB,qGAAqG,KAAK,IAAI,CAC/G,CAAC;KACH;AACH,CAAC,CAAC;AAbW,QAAA,eAAe,mBAa1B;AAEW,QAAA,IAAI,GAAiC;IAChD,SAAS,EAAE,KAAK;IAEhB;;;;;;OAMG;IACH,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,KAAK,MAAM;IAEjC;;;;;;;;OAQG;IACH,aAAa;QACX,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;;;;;;;;OASG;IACH,MAAM,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE;QACrC,MAAM,YAAY,GAAG,IAAA,uBAAe,EAAC,KAAK,CAAC,CAAC;QAE5C,2EAA2E;QAC3E,SAAS;QACT,IAAI,MAAM,EAAE;YACV,OAAO,IAAA,mBAAW,EAAC,CAAC,MAAM,EAAE,IAAA,qBAAa,EAAC,YAAY,CAAC,CAAC,CAAC,CAAC;SAC3D;QAED,wEAAwE;QACxE,+BAA+B;QAC/B,OAAO,eAAM,CAAC,MAAM,CAAC;YACnB,IAAI,EAAE,SAAS;YACf,MAAM;YACN,KAAK,EAAE,YAAY;YACnB,MAAM;YACN,KAAK;SACN,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,IAAI;QACT,wEAAwE;QACxE,+BAA+B;QAC/B,OAAO,eAAM,CAAC,MAAM,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC;IACnE,CAAC;CACF,CAAC","sourcesContent":["import { bigIntToBytes, concatBytes } from '@metamask/utils';\nimport { coerce, create, literal, union, boolean } from 'superstruct';\n\nimport { ParserError } from '../errors';\nimport { number } from './number';\nimport { Parser } from './parser';\n\n/**\n * A boolean-like value. This can be a boolean literal, or \"true\" or \"false\".\n */\nexport type BooleanLike = 'true' | 'false' | boolean;\n\nconst BooleanCoercer = coerce(\n  boolean(),\n  union([literal('true'), literal('false')]),\n  (value) => value === 'true',\n);\n\n/**\n * Normalize a boolean value. This accepts the boolean as:\n *\n * - A boolean literal.\n * - The string \"true\" or \"false\".\n *\n * @param value - The value to get a boolean for.\n * @returns The parsed boolean value. This is `BigInt(1)` for truthy values, or\n * `BigInt(0)` for falsy values.\n */\nexport const getBooleanValue = (value: BooleanLike): bigint => {\n  try {\n    const booleanValue = create(value, BooleanCoercer);\n    if (booleanValue) {\n      return BigInt(1);\n    }\n\n    return BigInt(0);\n  } catch {\n    throw new ParserError(\n      `Invalid boolean value. Expected a boolean literal, or the string \"true\" or \"false\", but received \"${value}\".`,\n    );\n  }\n};\n\nexport const bool: Parser<BooleanLike, boolean> = {\n  isDynamic: false,\n\n  /**\n   * Get if the given value is a valid boolean type. Since `bool` is a simple\n   * type, this is just a check that the value is \"bool\".\n   *\n   * @param type - The type to check.\n   * @returns Whether the type is a valid boolean type.\n   */\n  isType: (type) => type === 'bool',\n\n  /**\n   * Get the byte length of an encoded boolean. Since `bool` is a simple\n   * type, this always returns 32.\n   *\n   * Note that actual booleans are only 1 byte long, but the encoding of\n   * the `bool` type is always 32 bytes long.\n   *\n   * @returns The byte length of an encoded boolean.\n   */\n  getByteLength(): number {\n    return 32;\n  },\n\n  /**\n   * Encode the given boolean to a byte array.\n   *\n   * @param args - The encoding arguments.\n   * @param args.buffer - The byte array to add to.\n   * @param args.value - The boolean to encode.\n   * @param args.packed - Whether the value is packed.\n   * @param args.tight - Whether to use non-standard tight encoding.\n   * @returns The bytes with the encoded boolean added to it.\n   */\n  encode({ buffer, value, packed, tight }): Uint8Array {\n    const booleanValue = getBooleanValue(value);\n\n    // For packed encoding, we add a single byte (`0x00` or `0x01`) to the byte\n    // array.\n    if (packed) {\n      return concatBytes([buffer, bigIntToBytes(booleanValue)]);\n    }\n\n    // Booleans are encoded as 32-byte integers, so we use the number parser\n    // to encode the boolean value.\n    return number.encode({\n      type: 'uint256',\n      buffer,\n      value: booleanValue,\n      packed,\n      tight,\n    });\n  },\n\n  /**\n   * Decode the given byte array to a boolean.\n   *\n   * @param args - The decoding arguments.\n   * @returns The decoded boolean.\n   */\n  decode(args): boolean {\n    // Booleans are encoded as 32-byte integers, so we use the number parser\n    // to decode the boolean value.\n    return number.decode({ ...args, type: 'uint256' }) === BigInt(1);\n  },\n};\n"]}