{"version":3,"file":"packer.js","sourceRoot":"","sources":["../src/packer.ts"],"names":[],"mappings":";;;AAAA,2CAKyB;AAEzB,qCAAuC;AACvC,yCAAqC;AACrC,uCAWmB;AAEnB,mCAAwC;AAExC;;;;;;GAMG;AACI,MAAM,SAAS,GAAG,CAAC,IAAY,EAAU,EAAE;IAChD,MAAM,OAAO,GAA8B;QACzC,OAAO,EAAP,iBAAO;QACP,KAAK,EAAL,eAAK;QACL,IAAI,EAAJ,cAAI;QACJ,KAAK,EAAL,eAAK;QACL,UAAU,EAAV,oBAAU;QACV,QAAQ,EAAE,YAAE;QACZ,MAAM,EAAN,gBAAM;QACN,MAAM,EAAN,gBAAM;QACN,KAAK,EAAL,eAAK;KACN,CAAC;IAEF,MAAM,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;IACnC,IAAI,YAAY,EAAE;QAChB,OAAO,YAAY,CAAC;KACrB;IAED,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;IAC1E,IAAI,MAAM,EAAE;QACV,OAAO,MAAM,CAAC;KACf;IAED,MAAM,IAAI,oBAAW,CAAC,aAAa,IAAI,qBAAqB,CAAC,CAAC;AAChE,CAAC,CAAC;AAxBW,QAAA,SAAS,aAwBpB;AAEF;;;;;;;;GAQG;AACI,MAAM,eAAe,GAAG,CAAC,MAAc,EAAE,IAAY,EAAW,EAAE;IACvE,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,CAAC;IAC7B,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;QACnC,OAAO,SAAS,CAAC,IAAI,CAAC,CAAC;KACxB;IAED,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAPW,QAAA,eAAe,mBAO1B;AAgDF;;;;;;;;;;;;;;;;;;GAkBG;AACI,MAAM,IAAI,GAAG,CAAiC,EACnD,KAAK,EACL,MAAM,EACN,MAAM,GAAG,KAAK,EACd,KAAK,GAAG,KAAK,EACb,WAAW,GAAG,KAAK,EACnB,SAAS,GAAG,IAAI,UAAU,EAAE,GACb,EAAc,EAAE;IAC/B,IAAA,cAAM,EACJ,KAAK,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,EAC9B,IAAI,oBAAW,CACb,wBAAwB,KAAK,CAAC,MAAM,0CAA0C,MAAM,CAAC,MAAM,IAAI,CAChG,CACF,CAAC;IAEF,MAAM,EAAE,YAAY,EAAE,aAAa,EAAE,QAAQ,EAAE,GAAG,KAAK,CAAC,MAAM;IAC5D,wDAAwD;IACxD,CAAC,EAAE,YAAY,EAAE,aAAa,EAAE,QAAQ,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;QACzD,MAAM,MAAM,GAAG,IAAA,iBAAS,EAAC,IAAI,CAAC,CAAC;QAC/B,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;QAE5B,mEAAmE;QACnE,2CAA2C;QAC3C,IAAI,MAAM,IAAI,WAAW,IAAI,CAAC,IAAA,uBAAe,EAAC,MAAM,EAAE,IAAI,CAAC,EAAE;YAC3D,OAAO;gBACL,YAAY,EAAE,MAAM,CAAC,MAAM,CAAC;oBAC1B,MAAM,EAAE,YAAY;oBACpB,KAAK;oBACL,IAAI;oBACJ,MAAM;oBACN,KAAK;iBACN,CAAC;gBACF,aAAa;gBACb,QAAQ;aACT,CAAC;SACH;QAED,MAAM,eAAe,GAAG,IAAA,mBAAW,EAAC,CAAC,YAAY,EAAE,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACxE,MAAM,gBAAgB,GAAG,MAAM,CAAC,MAAM,CAAC;YACrC,MAAM,EAAE,aAAa;YACrB,KAAK;YACL,IAAI;YACJ,MAAM;YACN,KAAK;SACN,CAAC,CAAC;QAEH,OAAO;YACL,YAAY,EAAE,eAAe;YAC7B,aAAa,EAAE,gBAAgB;YAC/B,QAAQ,EAAE;gBACR,GAAG,QAAQ;gBACX,EAAE,QAAQ,EAAE,YAAY,CAAC,MAAM,EAAE,OAAO,EAAE,aAAa,CAAC,MAAM,EAAE;aACjE;SACF,CAAC;IACJ,CAAC,EACD;QACE,YAAY,EAAE,IAAI,UAAU,EAAE;QAC9B,aAAa,EAAE,IAAI,UAAU,EAAE;QAC/B,QAAQ,EAAE,EAAE;KACb,CACF,CAAC;IAEF,oEAAoE;IACpE,IAAA,cAAM,EACJ,CAAC,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,EACvD,IAAI,oBAAW,CAAC,qBAAqB,CAAC,CACvC,CAAC;IAEF,MAAM,YAAY,GAAG,YAAY,CAAC,MAAM,CAAC;IACzC,MAAM,aAAa,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE;QACtE,MAAM,MAAM,GAAG,IAAA,gBAAQ,EAAC,IAAA,qBAAa,EAAC,YAAY,GAAG,OAAO,CAAC,CAAC,CAAC;QAC/D,OAAO,IAAA,WAAG,EAAC,MAAM,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;IACvC,CAAC,EAAE,YAAY,CAAC,CAAC;IAEjB,OAAO,IAAA,mBAAW,EAAC,CAAC,SAAS,EAAE,aAAa,EAAE,aAAa,CAAC,CAAC,CAAC;AAChE,CAAC,CAAC;AA3EW,QAAA,IAAI,QA2Ef;AAEK,MAAM,MAAM,GAAG,CAIpB,KAAW,EACX,MAAkB,EACV,EAAE;IACV,MAAM,QAAQ,GAAG,IAAA,kBAAO,EAAC,MAAM,CAAC,CAAC;IAEjC,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;QACxB,MAAM,EACJ,KAAK,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,EACtB,IAAI,GACL,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;QACpB,IAAA,cAAM,EACJ,CAAC,IAAI,EACL,IAAI,oBAAW,CACb,yGAAyG,IAAI,IAAI,CAClH,CACF,CAAC;QAEF,MAAM,MAAM,GAAG,IAAA,iBAAS,EAAC,IAAI,CAAC,CAAC;QAC/B,MAAM,SAAS,GAAG,IAAA,uBAAe,EAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAEhD,IAAI,SAAS,EAAE;YACb,MAAM,OAAO,GAAG,IAAA,qBAAa,EAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;YACrD,MAAM,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YAExC,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;SACrD;QAED,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;IAC9C,CAAC,CAAsB,CAAC;AAC1B,CAAC,CAAC;AAjCW,QAAA,MAAM,UAiCjB","sourcesContent":["import {\n  assert,\n  bytesToNumber,\n  concatBytes,\n  numberToBytes,\n} from '@metamask/utils';\n\nimport { ParserError } from './errors';\nimport { iterate } from './iterator';\nimport {\n  address,\n  array,\n  bool,\n  bytes,\n  fixedBytes,\n  fn,\n  number,\n  Parser,\n  string,\n  tuple,\n} from './parsers';\nimport { TypeMap } from './types';\nimport { padStart, set } from './utils';\n\n/**\n * Get the parser for the specified type.\n *\n * @param type - The type to get a parser for.\n * @returns The parser.\n * @throws If there is no parser for the specified type.\n */\nexport const getParser = (type: string): Parser => {\n  const parsers: { [key: string]: Parser } = {\n    address,\n    array,\n    bool,\n    bytes,\n    fixedBytes,\n    function: fn,\n    number,\n    string,\n    tuple,\n  };\n\n  const staticParser = parsers[type];\n  if (staticParser) {\n    return staticParser;\n  }\n\n  const parser = Object.values(parsers).find((value) => value.isType(type));\n  if (parser) {\n    return parser;\n  }\n\n  throw new ParserError(`The type \"${type}\" is not supported.`);\n};\n\n/**\n * Check if the specified parser is dynamic, for the provided types. This is\n * primarily used for parsing tuples, where a tuple can be dynamic based on the\n * types. For other parsers, it will simply use the set `isDynamic` value.\n *\n * @param parser - The parser to check.\n * @param type - The type to check the parser with.\n * @returns Whether the parser is dynamic.\n */\nexport const isDynamicParser = (parser: Parser, type: string): boolean => {\n  const { isDynamic } = parser;\n  if (typeof isDynamic === 'function') {\n    return isDynamic(type);\n  }\n\n  return isDynamic;\n};\n\ntype Pointer = {\n  position: number;\n  pointer: number;\n};\n\ntype PackState = {\n  staticBuffer: Uint8Array;\n  dynamicBuffer: Uint8Array;\n  pointers: Pointer[];\n};\n\nexport type PackArgs<Type extends readonly string[]> = {\n  /**\n   * The types of the values to pack.\n   */\n  types: Type;\n\n  /**\n   * The values to pack.\n   */\n  values: TypeMap<Type, 'input'>;\n\n  /**\n   * Whether to use the non-standard packed mode.\n   */\n  packed?: boolean | undefined;\n\n  /**\n   * Whether to use tight packing mode. Only applicable when `packed` is true.\n   * When true, the packed mode will not add any padding bytes. This matches\n   * the packing behaviour of `ethereumjs-abi`, but is not standard.\n   */\n  tight?: boolean | undefined;\n\n  /**\n   * Whether to use the non-standard packed mode in \"array\" mode. This is\n   * normally only used by the {@link array} parser.\n   */\n  arrayPacked?: boolean | undefined;\n\n  /**\n   * The byte array to encode the values into.\n   */\n  byteArray?: Uint8Array;\n};\n\n/**\n * Pack the provided values in a buffer, encoded with the specified types. If a\n * buffer is specified, the resulting value will be concatenated with the\n * buffer.\n *\n * @param args - The arguments object.\n * @param args.types - The types of the values to pack.\n * @param args.values - The values to pack.\n * @param args.packed - Whether to use the non-standard packed mode. Defaults to\n * `false`.\n * @param args.arrayPacked - Whether to use the non-standard packed mode for\n * arrays. Defaults to `false`.\n * @param args.byteArray - The byte array to encode the values into. Defaults to\n * an empty array.\n * @param args.tight - Whether to use tight packing mode. Only applicable when\n * `packed` is true. When true, the packed mode will not add any padding bytes.\n * This matches the packing behaviour of `ethereumjs-abi`, but is not standard.\n * @returns The resulting encoded buffer.\n */\nexport const pack = <Type extends readonly string[]>({\n  types,\n  values,\n  packed = false,\n  tight = false,\n  arrayPacked = false,\n  byteArray = new Uint8Array(),\n}: PackArgs<Type>): Uint8Array => {\n  assert(\n    types.length === values.length,\n    new ParserError(\n      `The number of types (${types.length}) does not match the number of values (${values.length}).`,\n    ),\n  );\n\n  const { staticBuffer, dynamicBuffer, pointers } = types.reduce<PackState>(\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    ({ staticBuffer, dynamicBuffer, pointers }, type, index) => {\n      const parser = getParser(type);\n      const value = values[index];\n\n      // If packed mode is enabled, we can skip the dynamic check, as all\n      // values are encoded in the static buffer.\n      if (packed || arrayPacked || !isDynamicParser(parser, type)) {\n        return {\n          staticBuffer: parser.encode({\n            buffer: staticBuffer,\n            value,\n            type,\n            packed,\n            tight,\n          }),\n          dynamicBuffer,\n          pointers,\n        };\n      }\n\n      const newStaticBuffer = concatBytes([staticBuffer, new Uint8Array(32)]);\n      const newDynamicBuffer = parser.encode({\n        buffer: dynamicBuffer,\n        value,\n        type,\n        packed,\n        tight,\n      });\n\n      return {\n        staticBuffer: newStaticBuffer,\n        dynamicBuffer: newDynamicBuffer,\n        pointers: [\n          ...pointers,\n          { position: staticBuffer.length, pointer: dynamicBuffer.length },\n        ],\n      };\n    },\n    {\n      staticBuffer: new Uint8Array(),\n      dynamicBuffer: new Uint8Array(),\n      pointers: [],\n    },\n  );\n\n  // If packed mode is enabled, there shouldn't be any dynamic values.\n  assert(\n    (!packed && !arrayPacked) || dynamicBuffer.length === 0,\n    new ParserError('Invalid pack state.'),\n  );\n\n  const dynamicStart = staticBuffer.length;\n  const updatedBuffer = pointers.reduce((target, { pointer, position }) => {\n    const offset = padStart(numberToBytes(dynamicStart + pointer));\n    return set(target, offset, position);\n  }, staticBuffer);\n\n  return concatBytes([byteArray, updatedBuffer, dynamicBuffer]);\n};\n\nexport const unpack = <\n  Type extends readonly string[],\n  Output = TypeMap<Type, 'output'>,\n>(\n  types: Type,\n  buffer: Uint8Array,\n): Output => {\n  const iterator = iterate(buffer);\n\n  return types.map((type) => {\n    const {\n      value: { value, skip },\n      done,\n    } = iterator.next();\n    assert(\n      !done,\n      new ParserError(\n        `The encoded value is invalid for the provided types. Reached end of buffer while attempting to parse \"${type}\".`,\n      ),\n    );\n\n    const parser = getParser(type);\n    const isDynamic = isDynamicParser(parser, type);\n\n    if (isDynamic) {\n      const pointer = bytesToNumber(value.subarray(0, 32));\n      const target = buffer.subarray(pointer);\n\n      return parser.decode({ type, value: target, skip });\n    }\n\n    return parser.decode({ type, value, skip });\n  }) as unknown as Output;\n};\n"]}