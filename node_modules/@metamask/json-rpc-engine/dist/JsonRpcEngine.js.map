{"version":3,"file":"JsonRpcEngine.js","sourceRoot":"","sources":["../src/JsonRpcEngine.ts"],"names":[],"mappings":"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","sourcesContent":["import { errorCodes, JsonRpcError, serializeError } from '@metamask/rpc-errors';\nimport SafeEventEmitter from '@metamask/safe-event-emitter';\nimport type {\n  JsonRpcError as SerializedJsonRpcError,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcNotification,\n  Json,\n  JsonRpcParams,\n  PendingJsonRpcResponse,\n} from '@metamask/utils';\nimport { hasProperty, isJsonRpcRequest } from '@metamask/utils';\n\nexport type JsonRpcEngineCallbackError = Error | SerializedJsonRpcError | null;\n\nexport type JsonRpcEngineReturnHandler = (\n  done: (error?: JsonRpcEngineCallbackError) => void,\n) => void;\n\nexport type JsonRpcEngineNextCallback = (\n  returnHandlerCallback?: JsonRpcEngineReturnHandler,\n) => void;\n\nexport type JsonRpcEngineEndCallback = (\n  error?: JsonRpcEngineCallbackError,\n) => void;\n\nexport type JsonRpcMiddleware<\n  Params extends JsonRpcParams,\n  Result extends Json,\n> = {\n  (\n    req: JsonRpcRequest<Params>,\n    res: PendingJsonRpcResponse<Result>,\n    next: JsonRpcEngineNextCallback,\n    end: JsonRpcEngineEndCallback,\n  ): void;\n  destroy?: () => void | Promise<void>;\n};\n\nconst DESTROYED_ERROR_MESSAGE =\n  'This engine is destroyed and can no longer be used.';\n\nexport type JsonRpcNotificationHandler<Params extends JsonRpcParams> = (\n  notification: JsonRpcNotification<Params>,\n) => void | Promise<void>;\n\ntype JsonRpcEngineArgs = {\n  /**\n   * A function for handling JSON-RPC notifications. A JSON-RPC notification is\n   * defined as a JSON-RPC request without an `id` property. If this option is\n   * _not_ provided, notifications will be treated the same as requests. If this\n   * option _is_ provided, notifications will be passed to the handler\n   * function without touching the engine's middleware stack.\n   *\n   * This function should not throw or reject.\n   */\n  notificationHandler?: JsonRpcNotificationHandler<JsonRpcParams>;\n};\n\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nexport class JsonRpcEngine extends SafeEventEmitter {\n  /**\n   * Indicating whether this engine is destroyed or not.\n   */\n  #isDestroyed = false;\n\n  #middleware: JsonRpcMiddleware<JsonRpcParams, Json>[];\n\n  readonly #notificationHandler?:\n    | JsonRpcNotificationHandler<JsonRpcParams>\n    | undefined;\n\n  /**\n   * Constructs a {@link JsonRpcEngine} instance.\n   *\n   * @param options - Options bag.\n   * @param options.notificationHandler - A function for handling JSON-RPC\n   * notifications. A JSON-RPC notification is defined as a JSON-RPC request\n   * without an `id` property. If this option is _not_ provided, notifications\n   * will be treated the same as requests. If this option _is_ provided,\n   * notifications will be passed to the handler function without touching\n   * the engine's middleware stack. This function should not throw or reject.\n   */\n  constructor({ notificationHandler }: JsonRpcEngineArgs = {}) {\n    super();\n    this.#middleware = [];\n    this.#notificationHandler = notificationHandler;\n  }\n\n  /**\n   * Throws an error if this engine is destroyed.\n   */\n  #assertIsNotDestroyed() {\n    if (this.#isDestroyed) {\n      throw new Error(DESTROYED_ERROR_MESSAGE);\n    }\n  }\n\n  /**\n   * Calls the `destroy()` function of any middleware with that property, clears\n   * the middleware array, and marks this engine as destroyed. A destroyed\n   * engine cannot be used.\n   */\n  destroy(): void {\n    this.#middleware.forEach(\n      (middleware: JsonRpcMiddleware<JsonRpcParams, Json>) => {\n        if (\n          // `in` walks the prototype chain, which is probably the desired\n          // behavior here.\n          'destroy' in middleware &&\n          typeof middleware.destroy === 'function'\n        ) {\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          middleware.destroy();\n        }\n      },\n    );\n    this.#middleware = [];\n    this.#isDestroyed = true;\n  }\n\n  /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */\n  push<Params extends JsonRpcParams, Result extends Json>(\n    middleware: JsonRpcMiddleware<Params, Result>,\n  ): void {\n    this.#assertIsNotDestroyed();\n    this.#middleware.push(middleware as JsonRpcMiddleware<JsonRpcParams, Json>);\n  }\n\n  /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @param callback - An error-first callback that will receive the response.\n   */\n  handle<Params extends JsonRpcParams, Result extends Json>(\n    request: JsonRpcRequest<Params>,\n    callback: (error: unknown, response: JsonRpcResponse<Result>) => void,\n  ): void;\n\n  /**\n   * Handle a JSON-RPC notification.\n   *\n   * @param notification - The notification to handle.\n   * @param callback - An error-first callback that will receive a `void` response.\n   */\n  handle<Params extends JsonRpcParams>(\n    notification: JsonRpcNotification<Params>,\n    callback: (error: unknown, response: void) => void,\n  ): void;\n\n  /**\n   * Handle an array of JSON-RPC requests and/or notifications, and return an\n   * array of responses to any included requests.\n   *\n   * @param request - The requests to handle.\n   * @param callback - An error-first callback that will receive the array of\n   * responses.\n   */\n  handle<Params extends JsonRpcParams, Result extends Json>(\n    requests: (JsonRpcRequest<Params> | JsonRpcNotification<Params>)[],\n    callback: (error: unknown, responses: JsonRpcResponse<Result>[]) => void,\n  ): void;\n\n  /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The JSON-RPC request to handle.\n   * @returns The JSON-RPC response.\n   */\n  handle<Params extends JsonRpcParams, Result extends Json>(\n    request: JsonRpcRequest<Params>,\n  ): Promise<JsonRpcResponse<Result>>;\n\n  /**\n   * Handle a JSON-RPC notification.\n   *\n   * @param notification - The notification to handle.\n   */\n  handle<Params extends JsonRpcParams>(\n    notification: JsonRpcNotification<Params>,\n  ): Promise<void>;\n\n  /**\n   * Handle an array of JSON-RPC requests and/or notifications, and return an\n   * array of responses to any included requests.\n   *\n   * @param request - The JSON-RPC requests to handle.\n   * @returns An array of JSON-RPC responses.\n   */\n  handle<Params extends JsonRpcParams, Result extends Json>(\n    requests: (JsonRpcRequest<Params> | JsonRpcNotification<Params>)[],\n  ): Promise<JsonRpcResponse<Result>[]>;\n\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handle(req: unknown, callback?: any) {\n    this.#assertIsNotDestroyed();\n\n    if (callback && typeof callback !== 'function') {\n      throw new Error('\"callback\" must be a function if provided.');\n    }\n\n    if (Array.isArray(req)) {\n      if (callback) {\n        return this.#handleBatch(req, callback);\n      }\n      return this.#handleBatch(req);\n    }\n\n    if (callback) {\n      return this.#handle(req as JsonRpcRequest, callback);\n    }\n    return this._promiseHandle(req as JsonRpcRequest);\n  }\n\n  /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */\n  asMiddleware(): JsonRpcMiddleware<JsonRpcParams, Json> {\n    this.#assertIsNotDestroyed();\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    return async (req, res, next, end) => {\n      try {\n        const [middlewareError, isComplete, returnHandlers] =\n          await JsonRpcEngine.#runAllMiddleware(req, res, this.#middleware);\n\n        if (isComplete) {\n          await JsonRpcEngine.#runReturnHandlers(returnHandlers);\n          return end(middlewareError as JsonRpcEngineCallbackError);\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        return next(async (handlerCallback) => {\n          try {\n            await JsonRpcEngine.#runReturnHandlers(returnHandlers);\n            // TODO: Replace `any` with type\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } catch (error: any) {\n            return handlerCallback(error);\n          }\n          return handlerCallback();\n        });\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (error: any) {\n        return end(error);\n      }\n    };\n  }\n\n  /**\n   * Like _handle, but for batch requests.\n   */\n  #handleBatch(\n    reqs: (JsonRpcRequest | JsonRpcNotification)[],\n  ): Promise<JsonRpcResponse<Json>[]>;\n\n  /**\n   * Like _handle, but for batch requests.\n   */\n  #handleBatch(\n    reqs: (JsonRpcRequest | JsonRpcNotification)[],\n    callback: (error: unknown, responses?: JsonRpcResponse<Json>[]) => void,\n  ): Promise<void>;\n\n  /**\n   * Handles a batch of JSON-RPC requests, either in `async` or callback\n   * fashion.\n   *\n   * @param requests - The request objects to process.\n   * @param callback - The completion callback.\n   * @returns The array of responses, or nothing if a callback was specified.\n   */\n  async #handleBatch(\n    requests: (JsonRpcRequest | JsonRpcNotification)[],\n    callback?: (error: unknown, responses?: JsonRpcResponse<Json>[]) => void,\n  ): Promise<JsonRpcResponse<Json>[] | void> {\n    // The order here is important\n    try {\n      // If the batch is an empty array, the response array must contain a single object\n      if (requests.length === 0) {\n        const response: JsonRpcResponse<Json>[] = [\n          {\n            id: null,\n            jsonrpc: '2.0',\n            error: new JsonRpcError(\n              errorCodes.rpc.invalidRequest,\n              'Request batch must contain plain objects. Received an empty array',\n            ),\n          },\n        ];\n        if (callback) {\n          return callback(null, response);\n        }\n        return response;\n      }\n\n      // 2. Wait for all requests to finish, or throw on some kind of fatal\n      // error\n      const responses = (\n        await Promise.all(\n          // 1. Begin executing each request in the order received\n          requests.map(this._promiseHandle.bind(this)),\n        )\n      ).filter(\n        // Filter out any notification responses.\n        (response) => response !== undefined,\n      ) as JsonRpcResponse<Json>[];\n\n      // 3. Return batch response\n      if (callback) {\n        return callback(null, responses);\n      }\n      return responses;\n    } catch (error) {\n      if (callback) {\n        return callback(error);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * A promise-wrapped _handle.\n   *\n   * @param request - The JSON-RPC request.\n   * @returns The JSON-RPC response.\n   */\n  // This function is used in tests, so we cannot easily change it to use the\n  // hash syntax.\n  // eslint-disable-next-line no-restricted-syntax\n  private async _promiseHandle(\n    request: JsonRpcRequest | JsonRpcNotification,\n  ): Promise<JsonRpcResponse<Json> | void> {\n    return new Promise((resolve, reject) => {\n      this.#handle(request, (error, res) => {\n        // For notifications, the response will be `undefined`, and any caught\n        // errors are unexpected and should be surfaced to the caller.\n        if (error && res === undefined) {\n          reject(error);\n        } else {\n          // Excepting notifications, there will always be a response, and it will\n          // always have any error that is caught and propagated.\n          resolve(res);\n        }\n      }).catch(reject);\n    });\n  }\n\n  /**\n   * Ensures that the request / notification object is valid, processes it, and\n   * passes any error and response object to the given callback.\n   *\n   * Does not reject.\n   *\n   * @param callerReq - The request object from the caller.\n   * @param callback - The callback function.\n   * @returns Nothing.\n   */\n  async #handle(\n    callerReq: JsonRpcRequest | JsonRpcNotification,\n    callback: (error?: unknown, response?: JsonRpcResponse<Json>) => void,\n  ): Promise<void> {\n    if (\n      !callerReq ||\n      Array.isArray(callerReq) ||\n      typeof callerReq !== 'object'\n    ) {\n      const error = new JsonRpcError(\n        errorCodes.rpc.invalidRequest,\n        `Requests must be plain objects. Received: ${typeof callerReq}`,\n        { request: callerReq },\n      );\n      return callback(error, { id: null, jsonrpc: '2.0', error });\n    }\n\n    if (typeof callerReq.method !== 'string') {\n      const error = new JsonRpcError(\n        errorCodes.rpc.invalidRequest,\n        `Must specify a string method. Received: ${typeof callerReq.method}`,\n        { request: callerReq as Json },\n      );\n\n      if (this.#notificationHandler && !isJsonRpcRequest(callerReq)) {\n        // Do not reply to notifications, even if they are malformed.\n        return callback(null);\n      }\n\n      return callback(error, {\n        // Typecast: This could be a notification, but we want to access the\n        // `id` even if it doesn't exist.\n        id: (callerReq as JsonRpcRequest).id ?? null,\n        jsonrpc: '2.0',\n        error,\n      });\n    }\n\n    // Handle notifications.\n    // We can't use isJsonRpcNotification here because that narrows callerReq to\n    // \"never\" after the if clause for unknown reasons.\n    if (this.#notificationHandler && !isJsonRpcRequest(callerReq)) {\n      try {\n        await this.#notificationHandler(callerReq);\n      } catch (error) {\n        return callback(error);\n      }\n      return callback(null);\n    }\n\n    let error: JsonRpcEngineCallbackError = null;\n\n    // Handle requests.\n    // Typecast: Permit missing id's for backwards compatibility.\n    const req = { ...(callerReq as JsonRpcRequest) };\n    const res: PendingJsonRpcResponse<Json> = {\n      id: req.id,\n      jsonrpc: req.jsonrpc,\n    };\n\n    try {\n      await JsonRpcEngine.#processRequest(req, res, this.#middleware);\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (_error: any) {\n      // A request handler error, a re-thrown middleware error, or something\n      // unexpected.\n      error = _error;\n    }\n\n    if (error) {\n      // Ensure no result is present on an errored response\n      delete res.result;\n      if (!res.error) {\n        res.error = serializeError(error);\n      }\n    }\n\n    return callback(error, res as JsonRpcResponse<Json>);\n  }\n\n  /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   *\n   * @param req - The request object.\n   * @param res - The response object.\n   * @param middlewares - The stack of middleware functions.\n   */\n  static async #processRequest(\n    req: JsonRpcRequest,\n    res: PendingJsonRpcResponse<Json>,\n    middlewares: JsonRpcMiddleware<JsonRpcParams, Json>[],\n  ): Promise<void> {\n    const [error, isComplete, returnHandlers] =\n      await JsonRpcEngine.#runAllMiddleware(req, res, middlewares);\n\n    // Throw if \"end\" was not called, or if the response has neither a result\n    // nor an error.\n    JsonRpcEngine.#checkForCompletion(req, res, isComplete);\n\n    // The return handlers should run even if an error was encountered during\n    // middleware processing.\n    await JsonRpcEngine.#runReturnHandlers(returnHandlers);\n\n    // Now we re-throw the middleware processing error, if any, to catch it\n    // further up the call chain.\n    if (error) {\n      // eslint-disable-next-line @typescript-eslint/no-throw-literal\n      throw error;\n    }\n  }\n\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @param req - The request object.\n   * @param res - The response object.\n   * @param middlewares - The stack of middleware functions to execute.\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n  static async #runAllMiddleware(\n    req: JsonRpcRequest,\n    res: PendingJsonRpcResponse<Json>,\n    middlewares: JsonRpcMiddleware<JsonRpcParams, Json>[],\n  ): Promise<\n    [\n      unknown, // error\n      boolean, // isComplete\n      JsonRpcEngineReturnHandler[],\n    ]\n  > {\n    const returnHandlers: JsonRpcEngineReturnHandler[] = [];\n    let error = null;\n    let isComplete = false;\n\n    // Go down stack of middleware, call and collect optional returnHandlers\n    for (const middleware of middlewares) {\n      [error, isComplete] = await JsonRpcEngine.#runMiddleware(\n        req,\n        res,\n        middleware,\n        returnHandlers,\n      );\n\n      if (isComplete) {\n        break;\n      }\n    }\n    return [error, isComplete, returnHandlers.reverse()];\n  }\n\n  /**\n   * Runs an individual middleware function.\n   *\n   * @param request - The request object.\n   * @param response - The response object.\n   * @param middleware - The middleware function to execute.\n   * @param returnHandlers - The return handlers array for the current request.\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */\n  static async #runMiddleware(\n    request: JsonRpcRequest,\n    response: PendingJsonRpcResponse<Json>,\n    middleware: JsonRpcMiddleware<JsonRpcParams, Json>,\n    returnHandlers: JsonRpcEngineReturnHandler[],\n  ): Promise<[unknown, boolean]> {\n    return new Promise((resolve) => {\n      const end: JsonRpcEngineEndCallback = (error?: unknown) => {\n        const parsedError = error || response.error;\n        if (parsedError) {\n          response.error = serializeError(parsedError);\n        }\n        // True indicates that the request should end\n        resolve([parsedError, true]);\n      };\n\n      const next: JsonRpcEngineNextCallback = (\n        returnHandler?: JsonRpcEngineReturnHandler,\n      ) => {\n        if (response.error) {\n          end(response.error);\n        } else {\n          if (returnHandler) {\n            if (typeof returnHandler !== 'function') {\n              end(\n                new JsonRpcError(\n                  errorCodes.rpc.internal,\n                  `JsonRpcEngine: \"next\" return handlers must be functions. ` +\n                    `Received \"${typeof returnHandler}\" for request:\\n${jsonify(\n                      request,\n                    )}`,\n                  { request: request as Json },\n                ),\n              );\n            }\n            returnHandlers.push(returnHandler);\n          }\n\n          // False indicates that the request should not end\n          resolve([null, false]);\n        }\n      };\n\n      try {\n        middleware(request, response, next, end);\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (error: any) {\n        end(error);\n      }\n    });\n  }\n\n  /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   *\n   * @param handlers - The return handlers to execute.\n   */\n  static async #runReturnHandlers(\n    handlers: JsonRpcEngineReturnHandler[],\n  ): Promise<void> {\n    for (const handler of handlers) {\n      await new Promise<void>((resolve, reject) => {\n        handler((error) => (error ? reject(error) : resolve()));\n      });\n    }\n  }\n\n  /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   *\n   * @param request - The request object.\n   * @param response - The response object.\n   * @param isComplete - Boolean from {@link JsonRpcEngine.#runAllMiddleware}\n   * indicating whether a middleware ended the request.\n   */\n  static #checkForCompletion(\n    request: JsonRpcRequest,\n    response: PendingJsonRpcResponse<Json>,\n    isComplete: boolean,\n  ): void {\n    if (!hasProperty(response, 'result') && !hasProperty(response, 'error')) {\n      throw new JsonRpcError(\n        errorCodes.rpc.internal,\n        `JsonRpcEngine: Response has no error or result for request:\\n${jsonify(\n          request,\n        )}`,\n        { request: request as Json },\n      );\n    }\n\n    if (!isComplete) {\n      throw new JsonRpcError(\n        errorCodes.rpc.internal,\n        `JsonRpcEngine: Nothing ended request:\\n${jsonify(request)}`,\n        { request: request as Json },\n      );\n    }\n  }\n}\n\n/**\n * JSON-stringifies a request object.\n *\n * @param request - The request object to JSON-stringify.\n * @returns The JSON-stringified request object.\n */\nfunction jsonify(request: JsonRpcRequest): string {\n  return JSON.stringify(request, null, 2);\n}\n"]}