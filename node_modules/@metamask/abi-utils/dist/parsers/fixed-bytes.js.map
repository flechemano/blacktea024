{"version":3,"file":"fixed-bytes.js","sourceRoot":"","sources":["../../src/parsers/fixed-bytes.ts"],"names":[],"mappings":";;;AAAA,2CAA8E;AAE9E,sCAAwC;AACxC,oCAAkC;AAGlC,MAAM,WAAW,GAAG,sBAAsB,CAAC;AAE3C;;;;;;GAMG;AACI,MAAM,aAAa,GAAG,CAAC,IAAY,EAAU,EAAE;IACpD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAC3C,IAAA,cAAM,EACJ,KAAK,EACL,0EAA0E,IAAI,IAAI,CACnF,CAAC;IAEF,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IAC7B,IAAA,cAAM,EACJ,MAAM,GAAG,CAAC,IAAI,MAAM,IAAI,EAAE,EAC1B,IAAI,oBAAW,CACb,0EAA0E,IAAI,IAAI,CACnF,CACF,CAAC;IAEF,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAhBW,QAAA,aAAa,iBAgBxB;AAEW,QAAA,UAAU,GAAkC;IACvD,SAAS,EAAE,KAAK;IAEhB;;;;;OAKG;IACH,MAAM,CAAC,IAAY;QACjB,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAED;;;;OAIG;IACH,aAAa;QACX,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;;;;;;;;OASG;IACH,MAAM,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE;QACpC,MAAM,MAAM,GAAG,IAAA,qBAAa,EAAC,IAAI,CAAC,CAAC;QACnC,MAAM,WAAW,GAAG,IAAA,mBAAW,EAAC,KAAK,CAAC,CAAC;QAEvC,IAAA,cAAM,EACJ,WAAW,CAAC,MAAM,IAAI,MAAM,EAC5B,IAAI,oBAAW,CACb,8BAA8B,MAAM,oCAAoC,WAAW,CAAC,MAAM,GAAG,CAC9F,CACF,CAAC;QAEF,0EAA0E;QAC1E,gCAAgC;QAChC,IAAI,MAAM,EAAE;YACV,OAAO,IAAA,mBAAW,EAAC,CAAC,MAAM,EAAE,IAAA,cAAM,EAAC,WAAW,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;SAC3D;QAED,OAAO,IAAA,mBAAW,EAAC,CAAC,MAAM,EAAE,IAAA,cAAM,EAAC,WAAW,CAAC,CAAC,CAAC,CAAC;IACpD,CAAC;IAED;;;;;;;OAOG;IACH,MAAM,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE;QACpB,MAAM,MAAM,GAAG,IAAA,qBAAa,EAAC,IAAI,CAAC,CAAC;QAEnC,yEAAyE;QACzE,oBAAoB;QACpB,OAAO,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;IAChC,CAAC;CACF,CAAC","sourcesContent":["import { assert, BytesLike, concatBytes, createBytes } from '@metamask/utils';\n\nimport { ParserError } from '../errors';\nimport { padEnd } from '../utils';\nimport { Parser } from './parser';\n\nconst BYTES_REGEX = /^bytes([0-9]{1,2})$/u;\n\n/**\n * Get the length of the specified type. If a length is not specified, or if the\n * length is out of range (0 < n <= 32), this will throw an error.\n *\n * @param type - The type to get the length for.\n * @returns The byte length of the type.\n */\nexport const getByteLength = (type: string): number => {\n  const bytes = type.match(BYTES_REGEX)?.[1];\n  assert(\n    bytes,\n    `Invalid byte length. Expected a number between 1 and 32, but received \"${type}\".`,\n  );\n\n  const length = Number(bytes);\n  assert(\n    length > 0 && length <= 32,\n    new ParserError(\n      `Invalid byte length. Expected a number between 1 and 32, but received \"${type}\".`,\n    ),\n  );\n\n  return length;\n};\n\nexport const fixedBytes: Parser<BytesLike, Uint8Array> = {\n  isDynamic: false,\n\n  /**\n   * Check if a type is a fixed bytes type.\n   *\n   * @param type - The type to check.\n   * @returns Whether the type is a fixed bytes type.\n   */\n  isType(type: string): boolean {\n    return BYTES_REGEX.test(type);\n  },\n\n  /**\n   * Get the byte length of an encoded fixed bytes type.\n   *\n   * @returns The byte length of the type.\n   */\n  getByteLength(): number {\n    return 32;\n  },\n\n  /**\n   * Encode a fixed bytes value.\n   *\n   * @param args - The arguments to encode.\n   * @param args.type - The type of the value.\n   * @param args.buffer - The byte array to add to.\n   * @param args.value - The value to encode.\n   * @param args.packed - Whether to use packed encoding.\n   * @returns The bytes with the encoded value added to it.\n   */\n  encode({ type, buffer, value, packed }): Uint8Array {\n    const length = getByteLength(type);\n    const bufferValue = createBytes(value);\n\n    assert(\n      bufferValue.length <= length,\n      new ParserError(\n        `Expected a value of length ${length}, but received a value of length ${bufferValue.length}.`,\n      ),\n    );\n\n    // For packed encoding, the value is padded to the length of the type, and\n    // then added to the byte array.\n    if (packed) {\n      return concatBytes([buffer, padEnd(bufferValue, length)]);\n    }\n\n    return concatBytes([buffer, padEnd(bufferValue)]);\n  },\n\n  /**\n   * Decode a fixed bytes value.\n   *\n   * @param args - The arguments to decode.\n   * @param args.type - The type of the value.\n   * @param args.value - The value to decode.\n   * @returns The decoded value as a `Uint8Array`.\n   */\n  decode({ type, value }): Uint8Array {\n    const length = getByteLength(type);\n\n    // Since we're returning a `Uint8Array`, we use `slice` to copy the bytes\n    // into a new array.\n    return value.slice(0, length);\n  },\n};\n"]}