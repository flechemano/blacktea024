{"version":3,"file":"abi.js","sourceRoot":"","sources":["../src/abi.ts"],"names":[],"mappings":";AAAA,gFAAgF;AAChF,0BAA0B;AAC1B,qEAAqE;;;AAErE,2CAAiE;AAEjE,qCAAwD;AACxD,qCAAwC;AAGxC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkEG;AACI,MAAM,MAAM,GAAG,CACpB,KAAW,EACX,MAA8B,EAC9B,MAAgB,EAChB,KAAe,EACH,EAAE;IACd,IAAI;QACF,OAAO,IAAA,aAAI,EAAC,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;KAC/C;IAAC,OAAO,KAAK,EAAE;QACd,IAAI,KAAK,YAAY,oBAAW,EAAE;YAChC,MAAM,IAAI,oBAAW,CAAC,2BAA2B,KAAK,CAAC,OAAO,EAAE,EAAE,KAAK,CAAC,CAAC;SAC1E;QAED,MAAM,IAAI,oBAAW,CACnB,iCAAiC,IAAA,wBAAe,EAAC,KAAK,CAAC,EAAE,EACzD,KAAK,CACN,CAAC;KACH;AACH,CAAC,CAAC;AAlBW,QAAA,MAAM,UAkBjB;AAEF;;;;;;;;;;;;;;;;;;;GAmBG;AACI,MAAM,YAAY,GAAG,CAC1B,IAAU,EACV,KAAkC,EACtB,EAAE;IACd,OAAO,IAAA,cAAM,EAAC,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC;AALW,QAAA,YAAY,gBAKvB;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCG;AACI,MAAM,YAAY,GAAG,CAC1B,KAAW,EACX,MAA8B,EAC9B,KAAe,EACH,EAAE;IACd,OAAO,IAAA,cAAM,EAAC,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;AAC5C,CAAC,CAAC;AANW,QAAA,YAAY,gBAMvB;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCG;AACI,MAAM,MAAM,GAAG,CAIpB,KAAW,EACX,KAAgB,EACR,EAAE;IACV,MAAM,KAAK,GAAG,IAAA,mBAAW,EAAC,KAAK,CAAC,CAAC;IAEjC,IAAI;QACF,OAAO,IAAA,eAAM,EAAC,KAAK,EAAE,KAAK,CAAC,CAAC;KAC7B;IAAC,OAAO,KAAK,EAAE;QACd,IAAI,KAAK,YAAY,oBAAW,EAAE;YAChC,MAAM,IAAI,oBAAW,CAAC,2BAA2B,KAAK,CAAC,OAAO,EAAE,EAAE,KAAK,CAAC,CAAC;SAC1E;QAED,MAAM,IAAI,oBAAW,CACnB,iCAAiC,IAAA,wBAAe,EAAC,KAAK,CAAC,EAAE,EACzD,KAAK,CACN,CAAC;KACH;AACH,CAAC,CAAC;AArBW,QAAA,MAAM,UAqBjB;AAEF;;;;;;;;;;;;;;;;;;;GAmBG;AACI,MAAM,YAAY,GAAG,CAC1B,IAAU,EACV,KAAgB,EACc,EAAE;IAChC,MAAM,MAAM,GAAG,IAAA,cAAM,EAAC,CAAC,IAAI,CAAU,EAAE,KAAK,CAAC,CAAC;IAC9C,IAAA,cAAM,EACJ,MAAM,CAAC,MAAM,KAAK,CAAC,EACnB,IAAI,oBAAW,CAAC,4CAA4C,CAAC,CAC9D,CAAC;IAEF,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC;AAXW,QAAA,YAAY,gBAWvB","sourcesContent":["// ESLint gets confused by the nested list and tables in the docs, so we disable\n// the rule for this file.\n/* eslint-disable jsdoc/check-indentation, jsdoc/match-description */\n\nimport { assert, BytesLike, createBytes } from '@metamask/utils';\n\nimport { getErrorMessage, ParserError } from './errors';\nimport { pack, unpack } from './packer';\nimport { TypeMap } from './types';\n\n/**\n * Encode the data with the provided types. The types must be valid Solidity\n * ABI types.\n *\n * This will attempt to parse the values into the correct types. For example,\n * if you pass in a hex string for a `uint256`, it will be parsed into a\n * `bigint`. Regular strings are interpreted as UTF-8 strings. If you want to\n * pass in a hex string, you must pass it in as a `Uint8Array`, or use the\n * \"0x\"-prefix.\n *\n * It will also attempt to infer the types of the values. For example, if you\n * pass in a string for a `uint256`, it will result in a TypeScript compile-time\n * error. This does not work for all types, however. For example, if you use\n * nested arrays or tuples, the type will be inferred as `unknown`.\n *\n * The following types are supported:\n *\n * - `address`: A 20-byte Ethereum address.\n *   - As a 40-character-long hexadecimal string, starting with \"0x\".\n *   - As a 20-byte-long byte array, i.e., `Uint8Array`.\n * - `bool`: A boolean value.\n *   - As a boolean literal, i.e., `true` or `false`.\n *   - As the strings \"true\" or \"false\".\n * - `bytes(n)`: A dynamic byte array.\n *   - As a hexadecimal string, starting with \"0x\".\n *   - As a byte array, i.e., `Uint8Array`.\n *   - As a regular string, which will be interpreted as UTF-8.\n * - `function`: A Solidity function.\n *   - As a 48-character-long hexadecimal string, starting with \"0x\".\n *   - As a 24-byte-long byte array, i.e., `Uint8Array`.\n *   - As a {@link SolidityFunction} object.\n * - `int(n)`: A signed integer.\n *   - As a number.\n *   - As a `bigint`.\n *   - As a hexadecimal string, starting with \"0x\".\n * - `string`: A dynamic UTF-8 string.\n *   - As a regular string.\n *   - As a hexadecimal string, starting with \"0x\".\n *   - As a byte array, i.e., `Uint8Array`.\n * - `tuple`: A tuple of values.\n *   - As an array of values.\n * - `uint(n)`: An unsigned integer.\n *   - As a number.\n *   - As a `bigint`.\n *   - As a hexadecimal string, starting with \"0x\".\n *\n * @example\n * ```typescript\n * import { encode, decode } from '@metamask/abi-utils';\n *\n * const types = ['uint256', 'string'];\n * const encoded = encode(types, [42, 'Hello, world!']);\n * const decoded = decode(types, encoded);\n *\n * console.log(decoded); // [42n, 'Hello, world!']\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html\n * @param types - The types to encode.\n * @param values - The values to encode. This array must have the same length as\n * the types array.\n * @param packed - Whether to use the non-standard packed mode. Defaults to\n * `false`.\n * @param tight - Whether to pack the values tightly. When enabled, the values\n * will be packed without any padding. This matches the behaviour of\n * `ethereumjs-abi`. Defaults to `false`.\n * @returns The ABI encoded bytes.\n */\nexport const encode = <Type extends readonly string[]>(\n  types: Type,\n  values: TypeMap<Type, 'input'>,\n  packed?: boolean,\n  tight?: boolean,\n): Uint8Array => {\n  try {\n    return pack({ types, values, packed, tight });\n  } catch (error) {\n    if (error instanceof ParserError) {\n      throw new ParserError(`Unable to encode value: ${error.message}`, error);\n    }\n\n    throw new ParserError(\n      `An unexpected error occurred: ${getErrorMessage(error)}`,\n      error,\n    );\n  }\n};\n\n/**\n * Encode the data with the provided type. The type must be a valid Solidity\n * ABI type.\n *\n * See {@link encode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodeSingle, decodeSingle } from '@metamask/abi-utils';\n *\n * const encoded = encodeSingle('uint256', 42);\n * const decoded = decodeSingle('uint256', encoded);\n *\n * console.log(decoded); // 42n\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param type - The type to encode.\n * @param value - The value to encode.\n * @returns The ABI encoded bytes.\n */\nexport const encodeSingle = <Type extends string>(\n  type: Type,\n  value: TypeMap<[Type], 'input'>[0],\n): Uint8Array => {\n  return encode([type], [value]);\n};\n\n/**\n * Encode the data with the provided types. The types must be valid Solidity\n * ABI types. This is similar to {@link encode}, but the values are encoded in\n * the non-standard packed mode. This differs from the standard encoding in the\n * following ways:\n *\n * - Most values are packed tightly, without alignment padding.\n *   - The exception is array values, which are padded to 32 bytes.\n * - Values are still padded to their full size, i.e., `uint16` values are still\n *  padded to 2 bytes, regardless of the length of the value.\n * - The encoding of dynamic types (`bytes`, `string`) is different. The length\n * of the dynamic type is not included in the encoding, and the dynamic type is\n * not padded to a multiple of 32 bytes.\n * - All values are encoded in-place, without any offsets.\n *\n * The encoding of this is ambiguous as soon as there is more than one dynamic\n * type. That means that these values cannot be decoded with {@link decode} or\n * Solidity's `abi.decode` function.\n *\n * See {@link encode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodePacked } from '@metamask/abi-utils';\n *\n * const encoded = encodePacked(['uint8'], [42]);\n *\n * console.log(encoded); // `Uint8Array [ 42 ]`\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#non-standard-packed-mode\n * @param types - The types to encode.\n * @param values - The values to encode.\n * @param tight - Whether to pack the values tightly. When enabled, `bytesN`\n * values in arrays will be packed without any padding. This matches the\n * behaviour of `ethereumjs-abi`. Defaults to `false`.\n * @returns The ABI encoded bytes.\n */\nexport const encodePacked = <Type extends readonly string[]>(\n  types: Type,\n  values: TypeMap<Type, 'input'>,\n  tight?: boolean,\n): Uint8Array => {\n  return encode(types, values, true, tight);\n};\n\n/**\n * Decode an ABI encoded buffer with the specified types. The types must be\n * valid Solidity ABI types.\n *\n * This will attempt to infer the output types from the input types. For\n * example, if you use `uint256` as an input type, the output type will be\n * `bigint`. This does not work for all types, however. For example, if you use\n * nested array types or tuple types, the output type will be `unknown`.\n *\n * The resulting types of the values will be as follows:\n *\n * | Contract ABI Type | Resulting JavaScript Type |\n * | ----------------- | ------------------------- |\n * | `address`         | `string`                  |\n * | `bool`            | `boolean`                 |\n * | `bytes(n)`        | `Uint8Array`              |\n * | `function`        | {@link SolidityFunction}  |\n * | `int(n)`          | `bigint`                  |\n * | `string`          | `string`                  |\n * | `tuple`           | `Array`                   |\n * | `array`           | `Array`                   |\n * | `uint(n)`         | `bigint`                  |\n *\n * @example\n * ```typescript\n * import { encode, decode } from '@metamask/abi-utils';\n *\n * const types = ['uint256', 'string'];\n * const encoded = encode(types, [42, 'Hello, world!']);\n * const decoded = decode(types, encoded);\n *\n * console.log(decoded); // [42n, 'Hello, world!']\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param types - The types to decode the bytes with.\n * @param value - The bytes-like value to decode.\n * @returns The decoded values as array.\n */\nexport const decode = <\n  Type extends readonly string[],\n  Output = TypeMap<Type, 'output'>,\n>(\n  types: Type,\n  value: BytesLike,\n): Output => {\n  const bytes = createBytes(value);\n\n  try {\n    return unpack(types, bytes);\n  } catch (error) {\n    if (error instanceof ParserError) {\n      throw new ParserError(`Unable to decode value: ${error.message}`, error);\n    }\n\n    throw new ParserError(\n      `An unexpected error occurred: ${getErrorMessage(error)}`,\n      error,\n    );\n  }\n};\n\n/**\n * Decode the data with the provided type. The type must be a valid Solidity\n * ABI type.\n *\n * See {@link decode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodeSingle, decodeSingle } from '@metamask/abi-utils';\n *\n * const encoded = encodeSingle('uint256', 42);\n * const decoded = decodeSingle('uint256', encoded);\n *\n * console.log(decoded); // 42n\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param type - The type to decode.\n * @param value - The bytes-like value to decode.\n * @returns The decoded value.\n */\nexport const decodeSingle = <Type extends string>(\n  type: Type,\n  value: BytesLike,\n): TypeMap<[Type], 'output'>[0] => {\n  const result = decode([type] as const, value);\n  assert(\n    result.length === 1,\n    new ParserError('Decoded value array has unexpected length.'),\n  );\n\n  return result[0];\n};\n"]}