{"version":3,"file":"number.js","sourceRoot":"","sources":["../../src/parsers/number.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  assert,\n  bigIntToBytes,\n  bytesToBigInt,\n  bytesToSignedBigInt,\n  concatBytes,\n  createBigInt,\n  NumberLike,\n  signedBigIntToBytes,\n} from '@metamask/utils';\n\nimport { ParserError } from '../errors';\nimport { padStart } from '../utils';\nimport { DecodeArgs, Parser } from './parser';\n\nconst NUMBER_REGEX = /^u?int(?<length>[0-9]*)?$/u;\n\n/**\n * Check if a number type is signed.\n *\n * @param type - The type to check.\n * @returns Whether the type is signed.\n */\nexport const isSigned = (type: string): boolean => {\n  return !type.startsWith('u');\n};\n\n/**\n * Get the length of the specified type. If a length is not specified, if the\n * length is out of range (8 <= n <= 256), or if the length is not a multiple of\n * 8, this will throw an error.\n *\n * @param type - The type to get the length for.\n * @returns The bit length of the type.\n */\nexport const getLength = (type: string): number => {\n  if (type === 'int' || type === 'uint') {\n    return 256;\n  }\n\n  const match = type.match(NUMBER_REGEX);\n  assert(\n    match?.groups?.length,\n    new ParserError(\n      `Invalid number type. Expected a number type, but received \"${type}\".`,\n    ),\n  );\n\n  const length = parseInt(match.groups.length, 10);\n  assert(\n    length >= 8 && length <= 256,\n    new ParserError(\n      `Invalid number length. Expected a number between 8 and 256, but received \"${type}\".`,\n    ),\n  );\n\n  assert(\n    length % 8 === 0,\n    new ParserError(\n      `Invalid number length. Expected a multiple of 8, but received \"${type}\".`,\n    ),\n  );\n\n  return length;\n};\n\n/**\n * Assert that the byte length of the given value is in range for the given\n * number type.\n *\n * @param value - The value to check.\n * @param type - The type of the value.\n * @throws If the value is out of range for the type.\n */\nexport const assertNumberLength = (value: bigint, type: string) => {\n  const length = getLength(type);\n  const maxValue =\n    BigInt(2) ** BigInt(length - (isSigned(type) ? 1 : 0)) - BigInt(1);\n\n  if (isSigned(type)) {\n    // Signed types must be in the range of `-(2^(length - 1))` to\n    // `2^(length - 1) - 1`.\n    assert(\n      value >= -(maxValue + BigInt(1)) && value <= maxValue,\n      new ParserError(`Number \"${value}\" is out of range for type \"${type}\".`),\n    );\n\n    return;\n  }\n\n  // Unsigned types must be in the range of `0` to `2^length - 1`.\n  assert(\n    value <= maxValue,\n    new ParserError(`Number \"${value}\" is out of range for type \"${type}\".`),\n  );\n};\n\n/**\n * Normalize a `bigint` value. This accepts the value as:\n *\n * - A `bigint`.\n * - A `number`.\n * - A decimal string, i.e., a string that does not start with \"0x\".\n * - A hexadecimal string, i.e., a string that starts with \"0x\".\n *\n * @param value - The number-like value to parse.\n * @returns The value parsed as bigint.\n */\nexport const getBigInt = (value: NumberLike): bigint => {\n  try {\n    return createBigInt(value);\n  } catch {\n    throw new ParserError(\n      `Invalid number. Expected a valid number value, but received \"${value}\".`,\n    );\n  }\n};\n\nexport const number: Parser<NumberLike, bigint> = {\n  isDynamic: false,\n\n  /**\n   * Check if a type is a number type.\n   *\n   * @param type - The type to check.\n   * @returns Whether the type is a number type.\n   */\n  isType(type: string): boolean {\n    return NUMBER_REGEX.test(type);\n  },\n\n  /**\n   * Get the byte length of an encoded number type. Since `int` and `uint` are\n   * simple types, this will always return 32.\n   *\n   * @returns The byte length of the type.\n   */\n  getByteLength(): number {\n    return 32;\n  },\n\n  /**\n   * Encode a number value.\n   *\n   * @param args - The arguments to encode.\n   * @param args.type - The type of the value.\n   * @param args.buffer - The byte array to add to.\n   * @param args.value - The value to encode.\n   * @param args.packed - Whether to use packed encoding.\n   * @returns The bytes with the encoded value added to it.\n   */\n  encode({ type, buffer, value, packed }): Uint8Array {\n    const bigIntValue = getBigInt(value);\n\n    assertNumberLength(bigIntValue, type);\n\n    if (isSigned(type)) {\n      // For packed encoding, the value is padded to the length of the type, and\n      // then added to the byte array.\n      if (packed) {\n        const length = getLength(type) / 8;\n        return concatBytes([buffer, signedBigIntToBytes(bigIntValue, length)]);\n      }\n\n      return concatBytes([\n        buffer,\n        padStart(signedBigIntToBytes(bigIntValue, 32)),\n      ]);\n    }\n\n    // For packed encoding, the value is padded to the length of the type, and\n    // then added to the byte array.\n    if (packed) {\n      const length = getLength(type) / 8;\n      return concatBytes([\n        buffer,\n        padStart(bigIntToBytes(bigIntValue), length),\n      ]);\n    }\n\n    return concatBytes([buffer, padStart(bigIntToBytes(bigIntValue))]);\n  },\n\n  /**\n   * Decode a number value.\n   *\n   * @param args - The decoding arguments.\n   * @param args.type - The type of the value.\n   * @param args.value - The value to decode.\n   * @returns The decoded value.\n   */\n  decode({ type, value }: DecodeArgs): bigint {\n    const buffer = value.subarray(0, 32);\n    if (isSigned(type)) {\n      const numberValue = bytesToSignedBigInt(buffer);\n      assertNumberLength(numberValue, type);\n      return numberValue;\n    }\n\n    const numberValue = bytesToBigInt(buffer);\n    assertNumberLength(numberValue, type);\n    return numberValue;\n  },\n};\n"]}