"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Memory = void 0;
const ceil = (value, ceiling) => {
    const r = value % ceiling;
    if (r === 0) {
        return value;
    }
    else {
        return value + ceiling - r;
    }
};
const CONTAINER_SIZE = 8192;
/**
 * Memory implements a simple memory model
 * for the ethereum virtual machine.
 */
class Memory {
    constructor() {
        this._store = Buffer.alloc(0);
    }
    /**
     * Extends the memory given an offset and size. Rounds extended
     * memory to word-size.
     */
    extend(offset, size) {
        if (size === 0) {
            return;
        }
        const newSize = ceil(offset + size, 32);
        const sizeDiff = newSize - this._store.length;
        if (sizeDiff > 0) {
            this._store = Buffer.concat([
                this._store,
                Buffer.alloc(Math.ceil(sizeDiff / CONTAINER_SIZE) * CONTAINER_SIZE),
            ]);
        }
    }
    /**
     * Writes a byte array with length `size` to memory, starting from `offset`.
     * @param offset - Starting position
     * @param size - How many bytes to write
     * @param value - Value
     */
    write(offset, size, value) {
        if (size === 0) {
            return;
        }
        this.extend(offset, size);
        if (value.length !== size)
            throw new Error('Invalid value size');
        if (offset + size > this._store.length)
            throw new Error('Value exceeds memory capacity');
        value.copy(this._store, offset);
    }
    /**
     * Reads a slice of memory from `offset` till `offset + size` as a `Buffer`.
     * It fills up the difference between memory's length and `offset + size` with zeros.
     * @param offset - Starting position
     * @param size - How many bytes to read
     * @param avoidCopy - Avoid memory copy if possible for performance reasons (optional)
     */
    read(offset, size, avoidCopy) {
        this.extend(offset, size);
        const loaded = this._store.slice(offset, offset + size);
        if (avoidCopy === true) {
            return loaded;
        }
        return Buffer.from(loaded);
    }
}
exports.Memory = Memory;
//# sourceMappingURL=memory.js.map