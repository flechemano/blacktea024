{"version":3,"file":"tuple.js","sourceRoot":"","sources":["../../src/parsers/tuple.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport { ParserError } from '../errors';\nimport { getParser, isDynamicParser, pack, unpack } from '../packer';\nimport { Parser } from './parser';\n\nconst TUPLE_REGEX = /^\\((.+)\\)$/u;\n\nconst isTupleType = (type: string): boolean => TUPLE_REGEX.test(type);\n\n/**\n * Get elements from a tuple type.\n *\n * @param type - The tuple type to get the types for.\n * @returns The elements of the tuple as string array.\n */\nexport const getTupleElements = (type: string): string[] => {\n  assert(\n    type.startsWith('(') && type.endsWith(')'),\n    new ParserError(\n      `Invalid tuple type. Expected tuple type, but received \"${type}\".`,\n    ),\n  );\n\n  const elements: string[] = [];\n  let current = '';\n  let depth = 0;\n\n  for (let i = 1; i < type.length - 1; i++) {\n    const char = type[i];\n\n    if (char === ',' && depth === 0) {\n      elements.push(current.trim());\n      current = '';\n    } else {\n      current += char;\n\n      if (char === '(') {\n        depth += 1;\n      } else if (char === ')') {\n        depth -= 1;\n      }\n    }\n  }\n\n  if (current.trim()) {\n    elements.push(current.trim());\n  }\n\n  return elements;\n};\n\nexport const tuple: Parser<unknown[]> = {\n  /**\n   * Check if the tuple is dynamic. Tuples are dynamic if one or more elements\n   * of the tuple are dynamic.\n   *\n   * @param type - The type to check.\n   * @returns Whether the tuple is dynamic.\n   */\n  isDynamic(type: string): boolean {\n    const elements = getTupleElements(type);\n    return elements.some((element) => {\n      const parser = getParser(element);\n      return isDynamicParser(parser, element);\n    });\n  },\n\n  /**\n   * Check if a type is a tuple type.\n   *\n   * @param type - The type to check.\n   * @returns Whether the type is a tuple type.\n   */\n  isType(type: string): boolean {\n    return isTupleType(type);\n  },\n\n  /**\n   * Get the byte length of a tuple type. If the tuple is dynamic, this will\n   * always return 32. If the tuple is static, this will return the sum of the\n   * byte lengths of the tuple elements.\n   *\n   * @param type - The type to get the byte length for.\n   * @returns The byte length of the tuple type.\n   */\n  getByteLength(type: string): number {\n    if (isDynamicParser(this, type)) {\n      return 32;\n    }\n\n    const elements = getTupleElements(type);\n\n    return elements.reduce((total, element) => {\n      return total + getParser(element).getByteLength(element);\n    }, 0);\n  },\n\n  /**\n   * Encode a tuple value.\n   *\n   * @param args - The encoding arguments.\n   * @param args.type - The type of the value.\n   * @param args.buffer - The byte array to add to.\n   * @param args.value - The value to encode.\n   * @param args.packed - Whether to use non-standard packed encoding.\n   * @param args.tight - Whether to use non-standard tight encoding.\n   * @returns The bytes with the encoded value added to it.\n   */\n  encode({ type, buffer, value, packed, tight }): Uint8Array {\n    const elements = getTupleElements(type);\n    return pack({\n      types: elements,\n      values: value,\n      byteArray: buffer,\n      packed,\n      tight,\n    });\n  },\n\n  /**\n   * Decode a tuple value.\n   *\n   * @param args - The decoding arguments.\n   * @param args.type - The type of the value.\n   * @param args.value - The value to decode.\n   * @param args.skip - A function to skip a number of bytes.\n   * @returns The decoded value.\n   */\n  decode({ type, value, skip }): unknown[] {\n    const elements = getTupleElements(type);\n\n    const length = this.getByteLength(type) - 32;\n    skip(length);\n\n    return unpack(elements, value);\n  },\n};\n"]}