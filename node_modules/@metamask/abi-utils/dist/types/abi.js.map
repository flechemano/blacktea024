{"version":3,"file":"abi.js","sourceRoot":"","sources":["../../src/types/abi.ts"],"names":[],"mappings":"","sourcesContent":["import {\n  address,\n  bool,\n  bytes,\n  fn,\n  number,\n  Parser,\n  string,\n  tuple,\n} from '../parsers';\n\ntype BytesType = `bytes` | `bytes${number}`;\ntype IntegerType = `int` | `int${number}` | `uint` | `uint${number}`;\ntype TupleType = `(${string})`;\n\n/**\n * Infer the type of `Parser`. This results in an object containing the `input`\n * and `output` types of the parser.\n */\ntype ParserType<Type extends Parser> = Type extends Parser<infer I, infer O>\n  ? {\n      input: I;\n      output: O;\n    }\n  : never;\n\n/**\n * Map the `input` and `output` types of a parser to an array of types.\n */\ntype ArrayParserType<Type> = Type extends { input: infer I; output: infer O }\n  ? {\n      input: I[];\n      output: O[];\n    }\n  : never;\n\n/**\n * \"Simple\" types, i.e., types that are not arrays.\n */\ntype SimpleType = Record<BytesType, ParserType<typeof bytes>> &\n  Record<IntegerType, ParserType<typeof number>> &\n  Record<TupleType, ParserType<typeof tuple>> & {\n    address: ParserType<typeof address>;\n    bool: ParserType<typeof bool>;\n    function: ParserType<typeof fn>;\n    string: ParserType<typeof string>;\n  };\n\n/**\n * Dynamic array types, i.e., types that are arrays without a fixed length.\n */\ntype DynamicArray = {\n  [Key in keyof SimpleType as `${Key}[]`]: ArrayParserType<SimpleType[Key]>;\n};\n\n/**\n * Fixed array types, i.e., types that are arrays with a fixed length.\n */\ntype FixedArray = {\n  [Key in keyof SimpleType as `${Key}[${number}]`]: ArrayParserType<\n    SimpleType[Key]\n  >;\n};\n\n/**\n * All simple ABI types, and some basic array types. This does not include\n * nested arrays or tuples. Those are supported by the library, but the types\n * for those are not included here, and will result in `unknown` types.\n *\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n */\nexport type Type = SimpleType & DynamicArray & FixedArray;\n\n/**\n * Map an array of types to an array of their `input` or `output` types.\n *\n * Refer to {@link Type} to see which types are supported.\n *\n * @example\n * ```typescript\n * type OutputTypes = Map<[`uint256`, `bytes[]`, `string[2]`], 'output'>;\n * // Results in: [bigint, Uint8Array[], string[]]\n * ```\n */\nexport type TypeMap<\n  Input extends readonly (keyof Type | string)[],\n  IO extends 'input' | 'output',\n> = {\n  [Key in keyof Input]: Input[Key] extends keyof Type\n    ? Type[Input[Key]][IO]\n    : unknown;\n};\n"]}