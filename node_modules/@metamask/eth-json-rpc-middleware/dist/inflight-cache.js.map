{"version":3,"file":"inflight-cache.js","sourceRoot":"","sources":["../src/inflight-cache.ts"],"names":[],"mappings":"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","sourcesContent":["import { createAsyncMiddleware } from '@metamask/json-rpc-engine';\nimport type {\n  JsonRpcParams,\n  Json,\n  PendingJsonRpcResponse,\n} from '@metamask/utils';\nimport { klona } from 'klona/full';\n\nimport { projectLogger, createModuleLogger } from './logging-utils';\nimport type { JsonRpcRequestToCache, JsonRpcCacheMiddleware } from './types';\nimport { cacheIdentifierForRequest } from './utils/cache';\n\ntype RequestHandlers = (handledRes: PendingJsonRpcResponse<Json>) => void;\ninterface InflightRequest {\n  [cacheId: string]: RequestHandlers[];\n}\n\nconst log = createModuleLogger(projectLogger, 'inflight-cache');\n\nexport function createInflightCacheMiddleware(): JsonRpcCacheMiddleware<\n  JsonRpcParams,\n  Json\n> {\n  const inflightRequests: InflightRequest = {};\n\n  return createAsyncMiddleware(\n    async (req: JsonRpcRequestToCache<JsonRpcParams>, res, next) => {\n      // allow cach to be skipped if so specified\n      if (req.skipCache) {\n        return next();\n      }\n      // get cacheId, if cacheable\n      const cacheId: string | null = cacheIdentifierForRequest(req);\n      // if not cacheable, skip\n      if (!cacheId) {\n        log('Request is not cacheable, proceeding. req = %o', req);\n        return next();\n      }\n      // check for matching requests\n      let activeRequestHandlers: RequestHandlers[] = inflightRequests[cacheId];\n      // if found, wait for the active request to be handled\n      if (activeRequestHandlers) {\n        // setup the response listener and wait for it to be called\n        // it will handle copying the result and request fields\n        log(\n          'Running %i handler(s) for request %o',\n          activeRequestHandlers.length,\n          req,\n        );\n        await createActiveRequestHandler(res, activeRequestHandlers);\n        return undefined;\n      }\n      // setup response handler array for subsequent requests\n      activeRequestHandlers = [];\n      inflightRequests[cacheId] = activeRequestHandlers;\n      // allow request to be handled normally\n      log('Carrying original request forward %o', req);\n      // eslint-disable-next-line n/callback-return\n      await next();\n      // clear inflight requests\n      delete inflightRequests[cacheId];\n      // schedule activeRequestHandlers to be handled\n      log(\n        'Running %i collected handler(s) for request %o',\n        activeRequestHandlers.length,\n        req,\n      );\n      handleActiveRequest(res, activeRequestHandlers);\n      // complete\n      return undefined;\n    },\n  );\n\n  async function createActiveRequestHandler(\n    res: PendingJsonRpcResponse<Json>,\n    activeRequestHandlers: RequestHandlers[],\n  ): Promise<void> {\n    const { resolve, promise } = deferredPromise();\n    activeRequestHandlers.push((handledRes: PendingJsonRpcResponse<Json>) => {\n      // append a copy of the result and error to the response\n      res.result = klona(handledRes.result);\n      res.error = klona(handledRes.error);\n      resolve();\n    });\n    return promise;\n  }\n\n  function handleActiveRequest(\n    res: PendingJsonRpcResponse<Json>,\n    activeRequestHandlers: RequestHandlers[],\n  ): void {\n    // use setTimeout so we can resolve our original request first\n    setTimeout(() => {\n      activeRequestHandlers.forEach((handler) => {\n        try {\n          handler(res);\n        } catch (err) {\n          // catch error so all requests are handled correctly\n          console.error(err);\n        }\n      });\n    });\n  }\n}\n\nfunction deferredPromise() {\n  let resolve: any;\n  const promise: Promise<void> = new Promise((_resolve) => {\n    resolve = _resolve;\n  });\n  return { resolve, promise };\n}\n"]}