{"version":3,"file":"address.js","sourceRoot":"","sources":["../../src/parsers/address.ts"],"names":[],"mappings":";;;AAAA,2CAOyB;AAEzB,sCAAwC;AACxC,oCAAoC;AAGpC;;;;;;;;;;GAUG;AACI,MAAM,UAAU,GAAG,CAAC,KAAgB,EAAc,EAAE;IACzD,MAAM,UAAU,GAAG,IAAA,mBAAW,EAAC,KAAK,CAAC,CAAC;IACtC,IAAA,cAAM,EACJ,UAAU,CAAC,MAAM,IAAI,EAAE,EACvB,IAAI,oBAAW,CACb,6EAA6E,UAAU,CAAC,MAAM,SAAS,CACxG,CACF,CAAC;IAEF,OAAO,IAAA,gBAAQ,EAAC,UAAU,EAAE,EAAE,CAAC,CAAC;AAClC,CAAC,CAAC;AAVW,QAAA,UAAU,cAUrB;AAEW,QAAA,OAAO,GAA8B;IAChD,SAAS,EAAE,KAAK;IAEhB;;;;;;OAMG;IACH,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,KAAK,SAAS;IAEpC;;;;;;;;OAQG;IACH,aAAa;QACX,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;;;;;;;OAQG;IACH,MAAM,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE;QAC9B,MAAM,YAAY,GAAG,IAAA,kBAAU,EAAC,KAAK,CAAC,CAAC;QAEvC,2EAA2E;QAC3E,0CAA0C;QAC1C,IAAI,MAAM,EAAE;YACV,OAAO,IAAA,mBAAW,EAAC,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC,CAAC;SAC5C;QAED,MAAM,aAAa,GAAG,IAAA,gBAAQ,EAAC,YAAY,CAAC,CAAC;QAC7C,OAAO,IAAA,mBAAW,EAAC,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC,CAAC;IAC9C,CAAC;IAED;;;;;;;OAOG;IACH,MAAM,CAAC,EAAE,KAAK,EAAE;QACd,OAAO,IAAA,aAAK,EAAC,IAAA,kBAAU,EAAC,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;IAChD,CAAC;CACF,CAAC","sourcesContent":["import {\n  add0x,\n  assert,\n  BytesLike,\n  bytesToHex,\n  concatBytes,\n  createBytes,\n} from '@metamask/utils';\n\nimport { ParserError } from '../errors';\nimport { padStart } from '../utils';\nimport { Parser } from './parser';\n\n/**\n * Normalize an address value. This accepts the address as:\n *\n * - A hex string starting with the `0x` prefix.\n * - A byte array (`Uint8Array` or `Buffer`).\n *\n * It checks that the address is 20 bytes long.\n *\n * @param value - The value to normalize.\n * @returns The normalized address as `Uint8Array`.\n */\nexport const getAddress = (value: BytesLike): Uint8Array => {\n  const bytesValue = createBytes(value);\n  assert(\n    bytesValue.length <= 20,\n    new ParserError(\n      `Invalid address value. Expected address to be 20 bytes long, but received ${bytesValue.length} bytes.`,\n    ),\n  );\n\n  return padStart(bytesValue, 20);\n};\n\nexport const address: Parser<BytesLike, string> = {\n  isDynamic: false,\n\n  /**\n   * Get if the given value is a valid address type. Since `address` is a simple\n   * type, this is just a check that the value is \"address\".\n   *\n   * @param type - The type to check.\n   * @returns Whether the type is a valid address type.\n   */\n  isType: (type) => type === 'address',\n\n  /**\n   * Get the byte length of an encoded address. Since `address` is a simple\n   * type, this always returns 32.\n   *\n   * Note that actual addresses are only 20 bytes long, but the encoding of\n   * the `address` type is always 32 bytes long.\n   *\n   * @returns The byte length of an encoded address.\n   */\n  getByteLength(): number {\n    return 32;\n  },\n\n  /**\n   * Encode the given address to a 32-byte-long byte array.\n   *\n   * @param args - The encoding arguments.\n   * @param args.buffer - The byte array to add to.\n   * @param args.value - The address to encode.\n   * @param args.packed - Whether to use packed encoding.\n   * @returns The bytes with the encoded address added to it.\n   */\n  encode({ buffer, value, packed }): Uint8Array {\n    const addressValue = getAddress(value);\n\n    // If we're using packed encoding, we can just add the address bytes to the\n    // byte array, without adding any padding.\n    if (packed) {\n      return concatBytes([buffer, addressValue]);\n    }\n\n    const addressBuffer = padStart(addressValue);\n    return concatBytes([buffer, addressBuffer]);\n  },\n\n  /**\n   * Decode the given byte array to an address.\n   *\n   * @param args - The decoding arguments.\n   * @param args.value - The byte array to decode.\n   * @returns The decoded address as a hexadecimal string, starting with the\n   * \"0x\"-prefix.\n   */\n  decode({ value }): string {\n    return add0x(bytesToHex(value.slice(12, 32)));\n  },\n};\n"]}