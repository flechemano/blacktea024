{"version":3,"file":"iterator.js","sourceRoot":"","sources":["../src/iterator.ts"],"names":[],"mappings":";;;AAAA,2CAAyC;AAOzC;;;;;;;;;;;GAWG;AACI,MAAM,OAAO,GAAG,QAAQ,CAAC,EAC9B,MAAkB,EAClB,IAAI,GAAG,EAAE;IAET,KAAK,IAAI,OAAO,GAAG,CAAC,EAAE,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,IAAI,IAAI,EAAE;QAC9D,MAAM,IAAI,GAAG,CAAC,MAAc,EAAE,EAAE;YAC9B,IAAA,cAAM,EAAC,MAAM,IAAI,CAAC,EAAE,yCAAyC,CAAC,CAAC;YAC/D,IAAA,cAAM,EAAC,MAAM,GAAG,IAAI,KAAK,CAAC,EAAE,wCAAwC,CAAC,CAAC;YAEtE,OAAO,IAAI,MAAM,CAAC;QACpB,CAAC,CAAC;QAEF,MAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAEvC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;KACvB;IAED,OAAO;QACL,IAAI,EAAE,GAAG,EAAE,CAAC,SAAS;QACrB,KAAK,EAAE,IAAI,UAAU,EAAE;KACxB,CAAC;AACJ,CAAC,CAAC;AArBW,QAAA,OAAO,WAqBlB","sourcesContent":["import { assert } from '@metamask/utils';\n\ntype IteratorValue = {\n  skip(length: number): void;\n  value: Uint8Array;\n};\n\n/**\n * Iterate over a buffer with the specified size. This will yield a part of the\n * buffer starting at an increment of the specified size, until the end of the\n * buffer is reached.\n *\n * Calling the `skip` function will make it skip the specified number of bytes.\n *\n * @param buffer - The buffer to iterate over.\n * @param size - The number of bytes to iterate with.\n * @returns An iterator that yields the parts of the byte array.\n * @yields The parts of the byte array.\n */\nexport const iterate = function* (\n  buffer: Uint8Array,\n  size = 32,\n): Generator<IteratorValue, IteratorValue, IteratorValue> {\n  for (let pointer = 0; pointer < buffer.length; pointer += size) {\n    const skip = (length: number) => {\n      assert(length >= 0, 'Cannot skip a negative number of bytes.');\n      assert(length % size === 0, 'Length must be a multiple of the size.');\n\n      pointer += length;\n    };\n\n    const value = buffer.subarray(pointer);\n\n    yield { skip, value };\n  }\n\n  return {\n    skip: () => undefined,\n    value: new Uint8Array(),\n  };\n};\n"]}