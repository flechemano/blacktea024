{"version":3,"file":"array.js","sourceRoot":"","sources":["../../src/parsers/array.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  assert,\n  bytesToNumber,\n  concatBytes,\n  numberToBytes,\n} from '@metamask/utils';\n\nimport { ParserError } from '../errors';\nimport { getParser, isDynamicParser, pack, unpack } from '../packer';\nimport { padStart } from '../utils';\nimport { fixedBytes } from './fixed-bytes';\nimport { Parser } from './parser';\nimport { tuple } from './tuple';\n\nconst ARRAY_REGEX = /^(?<type>.*)\\[(?<length>\\d*?)\\]$/u;\n\nexport const isArrayType = (type: string): boolean => ARRAY_REGEX.test(type);\n\n/**\n * Get the type of the array.\n *\n * @param type - The type to get the array type for.\n * @returns The array type.\n */\nexport const getArrayType = (\n  type: string,\n): [type: string, length: number | undefined] => {\n  const match = type.match(ARRAY_REGEX);\n  assert(\n    match?.groups?.type,\n    new ParserError(\n      `Invalid array type. Expected an array type, but received \"${type}\".`,\n    ),\n  );\n\n  return [\n    match.groups.type,\n    match.groups.length ? parseInt(match.groups.length, 10) : undefined,\n  ];\n};\n\n/**\n * Get the type of the array as a tuple type. This is used for encoding fixed\n * length arrays, which are encoded as tuples.\n *\n * @param innerType - The type of the array.\n * @param length - The length of the array.\n * @returns The tuple type.\n */\nexport const getTupleType = (innerType: string, length: number): string => {\n  return `(${new Array(length).fill(innerType).join(',')})`;\n};\n\nexport const array: Parser<unknown[]> = {\n  /**\n   * Check if the array is dynamic. Arrays are dynamic if the array does not\n   * have a fixed length, or if the array type is dynamic.\n   *\n   * @param type - The type to check.\n   * @returns Whether the array is dynamic.\n   */\n  isDynamic(type: string): boolean {\n    const [innerType, length] = getArrayType(type);\n    return (\n      // `T[]` is dynamic for any `T`. `T[k]` is dynamic for any dynamic `T` and\n      // any `k >= 0`.\n      length === undefined || isDynamicParser(getParser(innerType), innerType)\n    );\n  },\n\n  /**\n   * Check if a type is an array type.\n   *\n   * @param type - The type to check.\n   * @returns Whether the type is an array type.\n   */\n  isType(type: string): boolean {\n    return isArrayType(type);\n  },\n\n  /**\n   * Get the byte length of an encoded array. If the array is dynamic, this\n   * returns 32, i.e., the length of the pointer to the array. If the array is\n   * static, this returns the byte length of the resulting tuple type.\n   *\n   * @param type - The type to get the byte length for.\n   * @returns The byte length of an encoded array.\n   */\n  getByteLength(type: string): number {\n    assert(\n      isArrayType(type),\n      new ParserError(`Expected an array type, but received \"${type}\".`),\n    );\n\n    const [innerType, length] = getArrayType(type);\n    if (!isDynamicParser(this, type) && length !== undefined) {\n      return tuple.getByteLength(getTupleType(innerType, length));\n    }\n\n    return 32;\n  },\n\n  /**\n   * Encode the given array to a byte array. If the array is static, this uses\n   * the tuple encoder.\n   *\n   * @param args - The encoding arguments.\n   * @param args.type - The type of the array.\n   * @param args.buffer - The byte array to add to.\n   * @param args.value - The array to encode.\n   * @param args.packed - Whether to use non-standard packed encoding.\n   * @param args.tight - Whether to use non-standard tight encoding.\n   * @returns The bytes with the encoded array added to it.\n   */\n  encode({ type, buffer, value, packed, tight }): Uint8Array {\n    const [arrayType, fixedLength] = getArrayType(type);\n\n    // Packed encoding does not support nested arrays.\n    assert(\n      !packed || !isArrayType(arrayType),\n      new ParserError(`Cannot pack nested arrays.`),\n    );\n\n    // Tightly pack `T[]` where `T` is a dynamic type. This is not supported in\n    // Solidity, but is commonly used in the Ethereum ecosystem.\n    if (packed && isDynamicParser(getParser(arrayType), arrayType)) {\n      return pack({\n        types: new Array(value.length).fill(arrayType),\n        values: value,\n        byteArray: buffer,\n        packed,\n        arrayPacked: true,\n        tight,\n      });\n    }\n\n    if (fixedLength) {\n      assert(\n        fixedLength === value.length,\n        new ParserError(\n          `Array length does not match type length. Expected a length of ${fixedLength}, but received ${value.length}.`,\n        ),\n      );\n\n      // `T[k]` for any `T` and `k` is encoded as `(T[0], ..., T[k - 1])`.\n      return tuple.encode({\n        type: getTupleType(arrayType, fixedLength),\n        buffer,\n        value,\n        // In \"tight\" mode, we don't pad the values to 32 bytes if the value is\n        // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we\n        // support to provide compatibility with it.\n        packed: fixedBytes.isType(arrayType) && tight,\n        tight,\n      });\n    }\n\n    // For packed encoding, we don't need to encode the length of the array,\n    // so we can just encode the values.\n    if (packed) {\n      return pack({\n        types: new Array(value.length).fill(arrayType),\n        values: value,\n        byteArray: buffer,\n        // In \"tight\" mode, we don't pad the values to 32 bytes if the value is\n        // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we\n        // support to provide compatibility with it.\n        packed: fixedBytes.isType(arrayType) && tight,\n        arrayPacked: true,\n        tight,\n      });\n    }\n\n    // `T[]` with `k` elements is encoded as `k (T[0], ..., T[k - 1])`. That\n    // means that we just need to encode the length of the array, and then the\n    // array itself. The pointer is encoded by the {@link pack} function.\n    const arrayLength = padStart(numberToBytes(value.length));\n    return pack({\n      types: new Array(value.length).fill(arrayType),\n      values: value,\n      byteArray: concatBytes([buffer, arrayLength]),\n      packed,\n      tight,\n    });\n  },\n\n  /**\n   * Decode an array from the given byte array.\n   *\n   * @param args - The decoding arguments.\n   * @param args.type - The type of the array.\n   * @param args.value - The byte array to decode.\n   * @returns The decoded array.\n   */\n  decode({ type, value, ...rest }): unknown[] {\n    const [arrayType, fixedLength] = getArrayType(type);\n\n    if (fixedLength) {\n      const result = tuple.decode({\n        type: getTupleType(arrayType, fixedLength),\n        value,\n        ...rest,\n      });\n\n      assert(\n        result.length === fixedLength,\n        new ParserError(\n          `Array length does not match type length. Expected a length of ${fixedLength}, but received ${result.length}.`,\n        ),\n      );\n\n      return result;\n    }\n\n    const arrayLength = bytesToNumber(value.subarray(0, 32));\n    return unpack(new Array(arrayLength).fill(arrayType), value.subarray(32));\n  },\n};\n"]}