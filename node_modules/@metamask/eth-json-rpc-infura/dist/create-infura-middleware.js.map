{"version":3,"file":"create-infura-middleware.js","sourceRoot":"","sources":["../src/create-infura-middleware.ts"],"names":[],"mappings":"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","sourcesContent":["import { createAsyncMiddleware } from '@metamask/json-rpc-engine';\nimport type { JsonRpcError } from '@metamask/rpc-errors';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  Json,\n  JsonRpcParams,\n  PendingJsonRpcResponse,\n} from '@metamask/utils';\n// eslint-disable-next-line @typescript-eslint/no-shadow\nimport fetch from 'node-fetch';\n\nimport { fetchConfigFromReq } from './fetch-config-from-req';\nimport { projectLogger, createModuleLogger } from './logging-utils';\nimport type {\n  ExtendedJsonRpcRequest,\n  InfuraJsonRpcSupportedNetwork,\n  RequestHeaders,\n} from './types';\n\nexport type CreateInfuraMiddlewareOptions = {\n  network?: InfuraJsonRpcSupportedNetwork;\n  maxAttempts?: number;\n  source?: string;\n  projectId: string;\n  headers?: Record<string, string>;\n};\n\nconst log = createModuleLogger(projectLogger, 'create-infura-middleware');\nconst RETRIABLE_ERRORS = [\n  // ignore server overload errors\n  'Gateway timeout',\n  'ETIMEDOUT',\n  'ECONNRESET',\n  // ignore server sent html error pages\n  // or truncated json responses\n  'SyntaxError',\n];\n\n/**\n * Builds [`@metamask/json-rpc-engine`](https://github.com/MetaMask/@metamask/json-rpc-engine)-compatible middleware designed\n * for interfacing with Infura's JSON-RPC endpoints.\n * @param opts - The options.\n * @param opts.network - A network that Infura supports; plugs into\n * `https://${network}.infura.io` (default: 'mainnet').\n * @param opts.maxAttempts - The number of times a request to Infura should be\n * retried in the case of failure (default: 5).\n * @param opts.source - A descriptor for the entity making the request; tracked\n * by Infura for analytics purposes.\n * @param opts.projectId - The Infura project id.\n * @param opts.headers - Extra headers that will be used to make the request.\n * @returns The `@metamask/json-rpc-engine`-compatible middleware.\n */\nexport function createInfuraMiddleware({\n  network = 'mainnet',\n  maxAttempts = 5,\n  source,\n  projectId,\n  headers = {},\n}: CreateInfuraMiddlewareOptions) {\n  // validate options\n  if (!projectId || typeof projectId !== 'string') {\n    throw new Error(`Invalid value for 'projectId': \"${projectId}\"`);\n  }\n\n  if (!headers || typeof headers !== 'object') {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`Invalid value for 'headers': \"${headers}\"`);\n  }\n\n  if (!maxAttempts) {\n    throw new Error(\n      `Invalid value for 'maxAttempts': \"${maxAttempts}\" (${typeof maxAttempts})`,\n    );\n  }\n\n  return createAsyncMiddleware(async (req, res) => {\n    // retry MAX_ATTEMPTS times, if error matches filter\n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n      try {\n        // attempt request\n        log(\n          'Attempting request to Infura. network = %o, projectId = %s, headers = %o, req = %o',\n          network,\n          projectId,\n          headers,\n          req,\n        );\n\n        await performFetch(network, projectId, headers, req, res, source);\n        // request was successful\n        break;\n      } catch (err: any) {\n        // an error was caught while performing the request\n        // if not retriable, resolve with the encountered error\n        if (!isRetriableError(err)) {\n          // abort with error\n          log(\n            'Non-retriable request error encountered. req = %o, res = %o, error = %o',\n            req,\n            res,\n            err,\n          );\n          throw err;\n        }\n        // if no more attempts remaining, throw an error\n        const remainingAttempts = maxAttempts - attempt;\n        if (!remainingAttempts) {\n          log(\n            'Retriable request error encountered, but exceeded max attempts. req = %o, res = %o, error = %o',\n            req,\n            res,\n            err,\n          );\n          const errMsg = `InfuraProvider - cannot complete request. All retries exhausted.\\nOriginal Error:\\n${\n            err.toString() as string\n          }\\n\\n`;\n          const retriesExhaustedErr = new Error(errMsg);\n          throw retriesExhaustedErr;\n        }\n\n        // otherwise, ignore error and retry again after timeout\n        log(\n          'Retriable request error encountered. req = %o, res = %o, error = %o',\n          req,\n          res,\n          err,\n        );\n        log('Waiting 1 second to try again...');\n        await timeout(1000);\n      }\n    }\n    // request was handled correctly, end\n  });\n}\n\n/**\n * Makes a request to Infura, updating the given response object if the response\n * has a \"successful\" status code or throwing an error otherwise.\n * @param network - A network that Infura supports; plugs into\n * `https://${network}.infura.io`.\n * @param projectId - The Infura project id.\n * @param extraHeaders - Extra headers that will be used to make the request.\n * @param req - The original request object obtained via the middleware stack.\n * @param res - The original response object obtained via the middleware stack.\n * @param source - A descriptor for the entity making the request;\n * tracked by Infura for analytics purposes.\n * @throws an error with a detailed message if the HTTP status code is anywhere\n * outside 2xx, and especially if it is 405, 429, 503, or 504.\n */\nasync function performFetch(\n  network: InfuraJsonRpcSupportedNetwork,\n  projectId: string,\n  extraHeaders: RequestHeaders,\n  req: ExtendedJsonRpcRequest<JsonRpcParams>,\n  res: PendingJsonRpcResponse<Json>,\n  source: string | undefined,\n): Promise<void> {\n  const { fetchUrl, fetchParams } = fetchConfigFromReq({\n    network,\n    projectId,\n    extraHeaders,\n    req,\n    source,\n  });\n  const response = await fetch(fetchUrl, fetchParams);\n  const rawData = await response.text();\n  // handle errors\n  if (!response.ok) {\n    switch (response.status) {\n      case 405:\n        throw rpcErrors.methodNotFound();\n\n      case 429:\n        throw createRatelimitError();\n\n      case 503:\n      case 504:\n        throw createTimeoutError();\n\n      default:\n        throw createInternalError(rawData);\n    }\n  }\n\n  // special case for now\n  if (req.method === 'eth_getBlockByNumber' && rawData === 'Not Found') {\n    // TODO Would this be more correct?\n    // delete res.result;\n    res.result = null as any as JsonRpcParams;\n    return;\n  }\n\n  // parse JSON\n  const data = JSON.parse(rawData);\n\n  // finally return result\n  res.result = data.result;\n  res.error = data.error;\n}\n\n/**\n * Builds a JSON-RPC 2.0 internal error object describing a rate-limiting\n * error.\n * @returns The error object.\n */\nfunction createRatelimitError(): JsonRpcError<undefined> {\n  const msg = `Request is being rate limited.`;\n  return createInternalError(msg);\n}\n\n/**\n * Builds a JSON-RPC 2.0 internal error object describing a timeout error.\n * @returns The error object.\n */\nfunction createTimeoutError(): JsonRpcError<undefined> {\n  let msg = `Gateway timeout. The request took too long to process. `;\n  msg += `This can happen when querying logs over too wide a block range.`;\n  return createInternalError(msg);\n}\n\n/**\n * Builds a JSON-RPC 2.0 internal error object.\n * @param msg - The message.\n * @returns The error object.\n */\nfunction createInternalError(msg: string): JsonRpcError<undefined> {\n  return rpcErrors.internal(msg);\n}\n\n/**\n * Upon making a request, we may get an error that is temporary and\n * intermittent. In these cases we can attempt the request again with the\n * assumption that the error is unlikely to occur again. Here we determine if we\n * have received such an error.\n * @param err - The error object.\n * @returns Whether the request that produced the error can be retried.\n */\nfunction isRetriableError(err: any): boolean {\n  const errMessage = err.toString();\n  return RETRIABLE_ERRORS.some((phrase) => errMessage.includes(phrase));\n}\n\n/**\n * A utility function that promisifies `setTimeout`.\n * @param length - The number of milliseconds to wait.\n * @returns A promise that resolves after the given time has elapsed.\n */\nasync function timeout(length: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, length);\n  });\n}\n"]}