{"version":3,"file":"function.js","sourceRoot":"","sources":["../../src/parsers/function.ts"],"names":[],"mappings":";;;AAAA,2CAOyB;AACzB,6CAAsE;AAEtE,sCAAwC;AACxC,+CAA2C;AA2B3C;;;;GAIG;AACH,MAAM,cAAc,GAAG,IAAA,oBAAM,EAC3B,IAAA,oBAAM,EAAC;IACL,OAAO,EAAE,uBAAe;IACxB,QAAQ,EAAE,uBAAe;CAC1B,CAAC,EACF,IAAA,mBAAK,EAAC,CAAC,uBAAe,EAAE,IAAA,sBAAQ,EAAC,UAAU,CAAC,CAAC,CAAC,EAC9C,CAAC,KAAK,EAAE,EAAE;IACR,MAAM,KAAK,GAAG,IAAA,mBAAW,EAAC,KAAK,CAAC,CAAC;IACjC,IAAA,cAAM,EACJ,KAAK,CAAC,MAAM,KAAK,EAAE,EACnB,IAAI,oBAAW,CACb,kFAAkF,KAAK,CAAC,MAAM,SAAS,CACxG,CACF,CAAC;IAEF,OAAO;QACL,OAAO,EAAE,IAAA,kBAAU,EAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QAC1C,QAAQ,EAAE,IAAA,kBAAU,EAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;KAC7C,CAAC;AACJ,CAAC,CACF,CAAC;AAEF;;;;;;;;;GASG;AACI,MAAM,WAAW,GAAG,CAAC,KAAmB,EAAc,EAAE;IAC7D,MAAM,KAAK,GAAG,IAAA,oBAAM,EAAC,KAAK,EAAE,cAAc,CAAC,CAAC;IAC5C,OAAO,IAAA,mBAAW,EAAC,CAAC,IAAA,kBAAU,EAAC,KAAK,CAAC,OAAO,CAAC,EAAE,IAAA,kBAAU,EAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AAC9E,CAAC,CAAC;AAHW,QAAA,WAAW,eAGtB;AAEW,QAAA,EAAE,GAA2C;IACxD,SAAS,EAAE,KAAK;IAEhB;;;;;;OAMG;IACH,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,KAAK,UAAU;IAErC;;;;;;;;OAQG;IACH,aAAa;QACX,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;;;;;;;;OASG;IACH,MAAM,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE;QACrC,MAAM,OAAO,GAAG,IAAA,mBAAW,EAAC,KAAK,CAAC,CAAC;QAEnC,yEAAyE;QACzE,uBAAuB;QACvB,OAAO,wBAAU,CAAC,MAAM,CAAC;YACvB,IAAI,EAAE,SAAS;YACf,MAAM;YACN,KAAK,EAAE,OAAO;YACd,MAAM;YACN,KAAK;SACN,CAAC,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,EAAE,KAAK,EAAE;QACd,OAAO;YACL,OAAO,EAAE,IAAA,kBAAU,EAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YACvC,QAAQ,EAAE,IAAA,kBAAU,EAAC,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;SAC1C,CAAC;IACJ,CAAC;CACF,CAAC","sourcesContent":["import {\n  assert,\n  bytesToHex,\n  concatBytes,\n  createBytes,\n  hexToBytes,\n  StrictHexStruct,\n} from '@metamask/utils';\nimport { coerce, create, instance, object, union } from 'superstruct';\n\nimport { ParserError } from '../errors';\nimport { fixedBytes } from './fixed-bytes';\nimport { Parser } from './parser';\n\n/**\n * A Solidity function-like value. This can be a hex string, a byte array, or a\n * {@link SolidityFunction} object.\n */\nexport type FunctionLike = string | Uint8Array | SolidityFunction;\n\n/**\n * A Solidity function, i.e., the address of a contract and the selector of a\n * function within that contract.\n */\nexport type SolidityFunction = {\n  /**\n   * The address of the contract. Must be a 40-character long hex string\n   * (excluding the \"0x\"-prefix).\n   */\n  address: string;\n\n  /**\n   * The selector of the function. Must be an 8-character long hex string\n   * (excluding the \"0x\"-prefix).\n   */\n  selector: string;\n};\n\n/**\n * A struct that represents a Solidity function. The value must be a hex string\n * or a byte array. The created value will always be an object with an `address`\n * and `selector` property.\n */\nconst FunctionStruct = coerce(\n  object({\n    address: StrictHexStruct,\n    selector: StrictHexStruct,\n  }),\n  union([StrictHexStruct, instance(Uint8Array)]),\n  (value) => {\n    const bytes = createBytes(value);\n    assert(\n      bytes.length === 24,\n      new ParserError(\n        `Invalid Solidity function. Expected function to be 24 bytes long, but received ${bytes.length} bytes.`,\n      ),\n    );\n\n    return {\n      address: bytesToHex(bytes.subarray(0, 20)),\n      selector: bytesToHex(bytes.subarray(20, 24)),\n    };\n  },\n);\n\n/**\n * Normalize a function. This accepts the function as:\n *\n * - A {@link SolidityFunction} object.\n * - A hexadecimal string.\n * - A byte array.\n *\n * @param input - The function-like input.\n * @returns The function as buffer.\n */\nexport const getFunction = (input: FunctionLike): Uint8Array => {\n  const value = create(input, FunctionStruct);\n  return concatBytes([hexToBytes(value.address), hexToBytes(value.selector)]);\n};\n\nexport const fn: Parser<FunctionLike, SolidityFunction> = {\n  isDynamic: false,\n\n  /**\n   * Check if a type is a function type. Since `function` is a simple type, this\n   * is just a check that the type is \"function\".\n   *\n   * @param type - The type to check.\n   * @returns Whether the type is a function type.\n   */\n  isType: (type) => type === 'function',\n\n  /**\n   * Get the byte length of an encoded function. Since `function` is a simple\n   * type, this always returns 32.\n   *\n   * Note that actual functions are only 24 bytes long, but the encoding of\n   * the `function` type is always 32 bytes long.\n   *\n   * @returns The byte length of an encoded function.\n   */\n  getByteLength(): number {\n    return 32;\n  },\n\n  /**\n   * Encode the given function to a byte array.\n   *\n   * @param args - The encoding arguments.\n   * @param args.buffer - The byte array to add to.\n   * @param args.value - The function to encode.\n   * @param args.packed - Whether to use packed encoding.\n   * @param args.tight - Whether to use non-standard tight encoding.\n   * @returns The bytes with the encoded function added to it.\n   */\n  encode({ buffer, value, packed, tight }): Uint8Array {\n    const fnValue = getFunction(value);\n\n    // Functions are encoded as `bytes24`, so we use the fixedBytes parser to\n    // encode the function.\n    return fixedBytes.encode({\n      type: 'bytes24',\n      buffer,\n      value: fnValue,\n      packed,\n      tight,\n    });\n  },\n\n  /**\n   * Decode the given byte array to a function.\n   *\n   * @param args - The decoding arguments.\n   * @param args.value - The byte array to decode.\n   * @returns The decoded function as a {@link SolidityFunction} object.\n   */\n  decode({ value }): SolidityFunction {\n    return {\n      address: bytesToHex(value.slice(0, 20)),\n      selector: bytesToHex(value.slice(20, 24)),\n    };\n  },\n};\n"]}