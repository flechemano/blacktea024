{"version":3,"file":"block-cache.js","sourceRoot":"","sources":["../src/block-cache.ts"],"names":[],"mappings":";;;AAAA,+DAAkE;AAIlE,mDAAoE;AASpE,yCAMuB;AAEvB,MAAM,GAAG,GAAG,IAAA,kCAAkB,EAAC,6BAAa,EAAE,aAAa,CAAC,CAAC;AAC7D,0EAA0E;AAC1E,MAAM,WAAW,GAAG,CAAC,SAAS,EAAE,IAAI,EAAE,iBAAiB,CAAC,CAAC;AAMzD,EAAE;AACF,mBAAmB;AACnB,EAAE;AAEF,MAAM,kBAAkB;IAGtB;QACE,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;IAClB,CAAC;IAED,aAAa,CAAC,cAAsB;QAClC,MAAM,WAAW,GAAW,MAAM,CAAC,QAAQ,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;QAChE,IAAI,UAAU,GAAe,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QACrD,+BAA+B;QAC/B,IAAI,CAAC,UAAU,EAAE;YACf,MAAM,QAAQ,GAAe,EAAE,CAAC;YAChC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;YACnC,UAAU,GAAG,QAAQ,CAAC;SACvB;QACD,OAAO,UAAU,CAAC;IACpB,CAAC;IAED,KAAK,CAAC,GAAG,CACP,OAAuB,EACvB,oBAA4B;QAE5B,qBAAqB;QACrB,MAAM,UAAU,GAAe,IAAI,CAAC,aAAa,CAAC,oBAAoB,CAAC,CAAC;QACxE,gCAAgC;QAChC,MAAM,UAAU,GAAkB,IAAA,iCAAyB,EAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAC3E,OAAO,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IACzD,CAAC;IAED,KAAK,CAAC,GAAG,CACP,OAAuB,EACvB,oBAA4B,EAC5B,MAAa;QAEb,qCAAqC;QACrC,MAAM,cAAc,GAAY,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QACrE,IAAI,CAAC,cAAc,EAAE;YACnB,OAAO;SACR;QAED,6BAA6B;QAC7B,MAAM,UAAU,GAAkB,IAAA,iCAAyB,EAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAC3E,IAAI,CAAC,UAAU,EAAE;YACf,OAAO;SACR;QACD,MAAM,UAAU,GAAe,IAAI,CAAC,aAAa,CAAC,oBAAoB,CAAC,CAAC;QACxE,UAAU,CAAC,UAAU,CAAC,GAAG,MAAM,CAAC;IAClC,CAAC;IAED,eAAe,CAAC,OAAuB;QACrC,uBAAuB;QACvB,IAAI,CAAC,IAAA,gBAAQ,EAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YAC7B,OAAO,KAAK,CAAC;SACd;QACD,iBAAiB;QACjB,MAAM,QAAQ,GAAG,IAAA,0BAAkB,EAAC,OAAO,CAAC,CAAC;QAE7C,IAAI,QAAQ,KAAK,SAAS,EAAE;YAC1B,OAAO,KAAK,CAAC;SACd;QACD,gBAAgB;QAChB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,cAAc,CAAC,OAAuB,EAAE,MAAa;QACnD,4CAA4C;QAC5C,IAAI,WAAW,CAAC,QAAQ,CAAC,MAAa,CAAC,EAAE;YACvC,OAAO,KAAK,CAAC;SACd;QAED,4DAA4D;QAC5D,IACE,OAAO,CAAC,MAAM;YACd,CAAC,0BAA0B,EAAE,2BAA2B,CAAC,CAAC,QAAQ,CAChE,OAAO,CAAC,MAAM,CACf,EACD;YACA,IACE,CAAC,MAAM;gBACP,CAAC,MAAM,CAAC,SAAS;gBACjB,MAAM,CAAC,SAAS;oBACd,oEAAoE,EACtE;gBACA,OAAO,KAAK,CAAC;aACd;SACF;QACD,iBAAiB;QACjB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,sEAAsE;IACtE,WAAW,CAAC,WAAmB;QAC7B,MAAM,cAAc,GAAW,MAAM,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;QAChE,mBAAmB;QACnB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;aACpB,GAAG,CAAC,MAAM,CAAC;aACX,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG,cAAc,CAAC;aACrC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;IAC9C,CAAC;CACF;AAED,SAAgB,0BAA0B,CAAC,EACzC,YAAY,MACmB,EAAE;IAIjC,mBAAmB;IACnB,IAAI,CAAC,YAAY,EAAE;QACjB,MAAM,IAAI,KAAK,CACb,+DAA+D,CAChE,CAAC;KACH;IAED,4BAA4B;IAC5B,MAAM,UAAU,GAAuB,IAAI,kBAAkB,EAAE,CAAC;IAChE,MAAM,UAAU,GAA0D;QACxE,CAAC,qBAAa,CAAC,SAAS,CAAC,EAAE,UAAU;QACrC,CAAC,qBAAa,CAAC,KAAK,CAAC,EAAE,UAAU;QACjC,CAAC,qBAAa,CAAC,IAAI,CAAC,EAAE,UAAU;QAChC,CAAC,qBAAa,CAAC,KAAK,CAAC,EAAE,SAAS;KACjC,CAAC;IAEF,OAAO,IAAA,uCAAqB,EAC1B,KAAK,EAAE,GAAyC,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;QAC7D,2CAA2C;QAC3C,IAAI,GAAG,CAAC,SAAS,EAAE;YACjB,OAAO,IAAI,EAAE,CAAC;SACf;QACD,mCAAmC;QACnC,MAAM,IAAI,GAAG,IAAA,0BAAkB,EAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC5C,MAAM,QAAQ,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;QAClC,2DAA2D;QAC3D,IAAI,CAAC,QAAQ,EAAE;YACb,OAAO,IAAI,EAAE,CAAC;SACf;QAED,uDAAuD;QACvD,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,GAAG,CAAC,EAAE;YAClC,OAAO,IAAI,EAAE,CAAC;SACf;QAED,0CAA0C;QAC1C,MAAM,eAAe,GAAG,IAAA,0BAAkB,EAAC,GAAG,CAAC,CAAC;QAChD,MAAM,QAAQ,GACZ,eAAe,IAAI,OAAO,eAAe,KAAK,QAAQ;YACpD,CAAC,CAAC,eAAe;YACjB,CAAC,CAAC,QAAQ,CAAC;QAEf,GAAG,CAAC,yBAAyB,EAAE,QAAQ,EAAE,GAAG,CAAC,CAAC;QAE9C,yBAAyB;QACzB,IAAI,oBAA4B,CAAC;QACjC,IAAI,QAAQ,KAAK,UAAU,EAAE;YAC3B,8CAA8C;YAC9C,oBAAoB,GAAG,MAAM,CAAC;SAC/B;aAAM,IAAI,QAAQ,KAAK,QAAQ,EAAE;YAChC,4BAA4B;YAC5B,GAAG,CAAC,qDAAqD,CAAC,CAAC;YAC3D,MAAM,iBAAiB,GAAG,MAAM,YAAY,CAAC,cAAc,EAAE,CAAC;YAC9D,sCAAsC;YACtC,GAAG,CACD,sDAAsD,EACtD,iBAAiB,CAClB,CAAC;YACF,UAAU,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC;YAC1C,oBAAoB,GAAG,iBAAiB,CAAC;SAC1C;aAAM;YACL,uBAAuB;YACvB,oBAAoB,GAAG,QAAQ,CAAC;SACjC;QACD,mCAAmC;QACnC,MAAM,WAAW,GAAsB,MAAM,QAAQ,CAAC,GAAG,CACvD,GAAG,EACH,oBAAoB,CACrB,CAAC;QACF,IAAI,WAAW,KAAK,SAAS,EAAE;YAC7B,aAAa;YACb,8CAA8C;YAC9C,GAAG,CACD,iEAAiE,EACjE,oBAAoB,CACrB,CAAC;YACF,6CAA6C;YAC7C,MAAM,IAAI,EAAE,CAAC;YAEb,sBAAsB;YACtB,oEAAoE;YACpE,wCAAwC;YACxC,GAAG,CAAC,uBAAuB,EAAE,GAAG,CAAC,CAAC;YAClC,MAAM,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,oBAAoB,EAAE,GAAG,CAAC,MAAe,CAAC,CAAC;SACpE;aAAM;YACL,4BAA4B;YAC5B,GAAG,CACD,8DAA8D,EAC9D,oBAAoB,CACrB,CAAC;YACF,GAAG,CAAC,MAAM,GAAG,WAAW,CAAC;SAC1B;QACD,OAAO,SAAS,CAAC;IACnB,CAAC,CACF,CAAC;AACJ,CAAC;AArGD,gEAqGC","sourcesContent":["import { createAsyncMiddleware } from '@metamask/json-rpc-engine';\nimport type { Json, JsonRpcParams, JsonRpcRequest } from '@metamask/utils';\nimport type { PollingBlockTracker } from 'eth-block-tracker';\n\nimport { projectLogger, createModuleLogger } from './logging-utils';\nimport type {\n  Block,\n  BlockCache,\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Cache,\n  JsonRpcCacheMiddleware,\n  JsonRpcRequestToCache,\n} from './types';\nimport {\n  cacheIdentifierForRequest,\n  blockTagForRequest,\n  cacheTypeForMethod,\n  canCache,\n  CacheStrategy,\n} from './utils/cache';\n\nconst log = createModuleLogger(projectLogger, 'block-cache');\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e'];\n\ninterface BlockCacheMiddlewareOptions {\n  blockTracker?: PollingBlockTracker;\n}\n\n//\n// Cache Strategies\n//\n\nclass BlockCacheStrategy {\n  private cache: Cache;\n\n  constructor() {\n    this.cache = {};\n  }\n\n  getBlockCache(blockNumberHex: string): BlockCache {\n    const blockNumber: number = Number.parseInt(blockNumberHex, 16);\n    let blockCache: BlockCache = this.cache[blockNumber];\n    // create new cache if necesary\n    if (!blockCache) {\n      const newCache: BlockCache = {};\n      this.cache[blockNumber] = newCache;\n      blockCache = newCache;\n    }\n    return blockCache;\n  }\n\n  async get(\n    request: JsonRpcRequest,\n    requestedBlockNumber: string,\n  ): Promise<Block | undefined> {\n    // lookup block cache\n    const blockCache: BlockCache = this.getBlockCache(requestedBlockNumber);\n    // lookup payload in block cache\n    const identifier: string | null = cacheIdentifierForRequest(request, true);\n    return identifier ? blockCache[identifier] : undefined;\n  }\n\n  async set(\n    request: JsonRpcRequest,\n    requestedBlockNumber: string,\n    result: Block,\n  ): Promise<void> {\n    // check if we can cached this result\n    const canCacheResult: boolean = this.canCacheResult(request, result);\n    if (!canCacheResult) {\n      return;\n    }\n\n    // set the value in the cache\n    const identifier: string | null = cacheIdentifierForRequest(request, true);\n    if (!identifier) {\n      return;\n    }\n    const blockCache: BlockCache = this.getBlockCache(requestedBlockNumber);\n    blockCache[identifier] = result;\n  }\n\n  canCacheRequest(request: JsonRpcRequest): boolean {\n    // check request method\n    if (!canCache(request.method)) {\n      return false;\n    }\n    // check blockTag\n    const blockTag = blockTagForRequest(request);\n\n    if (blockTag === 'pending') {\n      return false;\n    }\n    // can be cached\n    return true;\n  }\n\n  canCacheResult(request: JsonRpcRequest, result: Block): boolean {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result as any)) {\n      return false;\n    }\n\n    // check if transactions have block reference before caching\n    if (\n      request.method &&\n      ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(\n        request.method,\n      )\n    ) {\n      if (\n        !result ||\n        !result.blockHash ||\n        result.blockHash ===\n          '0x0000000000000000000000000000000000000000000000000000000000000000'\n      ) {\n        return false;\n      }\n    }\n    // otherwise true\n    return true;\n  }\n\n  // removes all block caches with block number lower than `oldBlockHex`\n  clearBefore(oldBlockHex: string): void {\n    const oldBlockNumber: number = Number.parseInt(oldBlockHex, 16);\n    // clear old caches\n    Object.keys(this.cache)\n      .map(Number)\n      .filter((num) => num < oldBlockNumber)\n      .forEach((num) => delete this.cache[num]);\n  }\n}\n\nexport function createBlockCacheMiddleware({\n  blockTracker,\n}: BlockCacheMiddlewareOptions = {}): JsonRpcCacheMiddleware<\n  JsonRpcParams,\n  Json\n> {\n  // validate options\n  if (!blockTracker) {\n    throw new Error(\n      'createBlockCacheMiddleware - No PollingBlockTracker specified',\n    );\n  }\n\n  // create caching strategies\n  const blockCache: BlockCacheStrategy = new BlockCacheStrategy();\n  const strategies: Record<CacheStrategy, BlockCacheStrategy | undefined> = {\n    [CacheStrategy.Permanent]: blockCache,\n    [CacheStrategy.Block]: blockCache,\n    [CacheStrategy.Fork]: blockCache,\n    [CacheStrategy.Never]: undefined,\n  };\n\n  return createAsyncMiddleware(\n    async (req: JsonRpcRequestToCache<JsonRpcParams>, res, next) => {\n      // allow cach to be skipped if so specified\n      if (req.skipCache) {\n        return next();\n      }\n      // check type and matching strategy\n      const type = cacheTypeForMethod(req.method);\n      const strategy = strategies[type];\n      // If there's no strategy in place, pass it down the chain.\n      if (!strategy) {\n        return next();\n      }\n\n      // If the strategy can't cache this request, ignore it.\n      if (!strategy.canCacheRequest(req)) {\n        return next();\n      }\n\n      // get block reference (number or keyword)\n      const requestBlockTag = blockTagForRequest(req);\n      const blockTag =\n        requestBlockTag && typeof requestBlockTag === 'string'\n          ? requestBlockTag\n          : 'latest';\n\n      log('blockTag = %o, req = %o', blockTag, req);\n\n      // get exact block number\n      let requestedBlockNumber: string;\n      if (blockTag === 'earliest') {\n        // this just exists for symmetry with \"latest\"\n        requestedBlockNumber = '0x00';\n      } else if (blockTag === 'latest') {\n        // fetch latest block number\n        log('Fetching latest block number to determine cache key');\n        const latestBlockNumber = await blockTracker.getLatestBlock();\n        // clear all cache before latest block\n        log(\n          'Clearing values stored under block numbers before %o',\n          latestBlockNumber,\n        );\n        blockCache.clearBefore(latestBlockNumber);\n        requestedBlockNumber = latestBlockNumber;\n      } else {\n        // We have a hex number\n        requestedBlockNumber = blockTag;\n      }\n      // end on a hit, continue on a miss\n      const cacheResult: Block | undefined = await strategy.get(\n        req,\n        requestedBlockNumber,\n      );\n      if (cacheResult === undefined) {\n        // cache miss\n        // wait for other middleware to handle request\n        log(\n          'No cache stored under block number %o, carrying request forward',\n          requestedBlockNumber,\n        );\n        // eslint-disable-next-line n/callback-return\n        await next();\n\n        // add result to cache\n        // it's safe to cast res.result as Block, due to runtime type checks\n        // performed when strategy.set is called\n        log('Populating cache with', res);\n        await strategy.set(req, requestedBlockNumber, res.result as Block);\n      } else {\n        // fill in result from cache\n        log(\n          'Cache hit, reusing cache result stored under block number %o',\n          requestedBlockNumber,\n        );\n        res.result = cacheResult;\n      }\n      return undefined;\n    },\n  );\n}\n"]}