{"version":3,"file":"bytes.js","sourceRoot":"","sources":["../../src/parsers/bytes.ts"],"names":[],"mappings":";;;AAAA,2CAMyB;AAEzB,oCAA4C;AAG/B,QAAA,KAAK,GAAkC;IAClD,SAAS,EAAE,IAAI;IAEf;;;;;;OAMG;IACH,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,KAAK,OAAO;IAElC;;;;;;;;OAQG;IACH,aAAa;QACX,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;;;;;;;OAQG;IACH,MAAM,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE;QAC9B,MAAM,WAAW,GAAG,IAAA,mBAAW,EAAC,KAAK,CAAC,CAAC;QAEvC,0EAA0E;QAC1E,oEAAoE;QACpE,kCAAkC;QAClC,IAAI,MAAM,EAAE;YACV,OAAO,IAAA,mBAAW,EAAC,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC,CAAC;SAC3C;QAED,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;QAE/D,2DAA2D;QAC3D,OAAO,IAAA,mBAAW,EAAC;YACjB,MAAM;YACN,IAAA,gBAAQ,EAAC,IAAA,qBAAa,EAAC,WAAW,CAAC,UAAU,CAAC,CAAC;YAC/C,IAAA,cAAM,EAAC,WAAW,EAAE,UAAU,CAAC;SAChC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,EAAE,KAAK,EAAE;QACd,MAAM,UAAU,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QACzC,MAAM,MAAM,GAAG,IAAA,qBAAa,EAAC,UAAU,CAAC,CAAC;QAEzC,yEAAyE;QACzE,oBAAoB;QACpB,OAAO,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,GAAG,MAAM,CAAC,CAAC;IACtC,CAAC;CACF,CAAC","sourcesContent":["import {\n  BytesLike,\n  bytesToNumber,\n  concatBytes,\n  createBytes,\n  numberToBytes,\n} from '@metamask/utils';\n\nimport { padEnd, padStart } from '../utils';\nimport { Parser } from './parser';\n\nexport const bytes: Parser<BytesLike, Uint8Array> = {\n  isDynamic: true,\n\n  /**\n   * Check if a type is a bytes type. Since `bytes` is a simple type, this is\n   * just a check that the type is \"bytes\".\n   *\n   * @param type - The type to check.\n   * @returns Whether the type is a bytes type.\n   */\n  isType: (type) => type === 'bytes',\n\n  /**\n   * Get the byte length of an encoded bytes value. Since `bytes` is a simple\n   * type, this always returns 32.\n   *\n   * Note that actual length of a bytes value is variable, but the encoded\n   * static value (pointer) is always 32 bytes long.\n   *\n   * @returns The byte length of an encoded bytes value.\n   */\n  getByteLength(): number {\n    return 32;\n  },\n\n  /**\n   * Encode the given bytes value to a byte array.\n   *\n   * @param args - The encoding arguments.\n   * @param args.buffer - The byte array to add to.\n   * @param args.value - The bytes value to encode.\n   * @param args.packed - Whether to use packed encoding.\n   * @returns The bytes with the encoded bytes value added to it.\n   */\n  encode({ buffer, value, packed }): Uint8Array {\n    const bufferValue = createBytes(value);\n\n    // For packed encoding, we can just add the bytes value to the byte array,\n    // without adding any padding or alignment. There is also no need to\n    // encode the length of the bytes.\n    if (packed) {\n      return concatBytes([buffer, bufferValue]);\n    }\n\n    const paddedSize = Math.ceil(bufferValue.byteLength / 32) * 32;\n\n    // Bytes of length `k` are encoded as `k pad_right(bytes)`.\n    return concatBytes([\n      buffer,\n      padStart(numberToBytes(bufferValue.byteLength)),\n      padEnd(bufferValue, paddedSize),\n    ]);\n  },\n\n  /**\n   * Decode the given byte array to a bytes value.\n   *\n   * @param args - The decoding arguments.\n   * @param args.value - The byte array to decode.\n   * @returns The decoded bytes value as a `Uint8Array`.\n   */\n  decode({ value }): Uint8Array {\n    const bytesValue = value.subarray(0, 32);\n    const length = bytesToNumber(bytesValue);\n\n    // Since we're returning a `Uint8Array`, we use `slice` to copy the bytes\n    // into a new array.\n    return value.slice(32, 32 + length);\n  },\n};\n"]}